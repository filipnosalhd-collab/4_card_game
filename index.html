<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="theme-color" content="#1a0a0a" />
    <title>4 Cards - Cztero Karcianka</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Crimson+Pro:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --gold: #d4af37;
        --gold-light: #f4d03f;
        --gold-dark: #b8860b;
        --crimson: #8b0000;
        --crimson-light: #a52a2a;
        --velvet: #1a0a0a;
        --velvet-light: #2d1515;
        --cream: #faf3e0;
        --card-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      html {
        overflow-x: hidden;
      }

      body {
        font-family: "Crimson Pro", Georgia, serif;
        background: radial-gradient(
          ellipse at center,
          var(--velvet-light) 0%,
          var(--velvet) 100%
        );
        min-height: 100vh;
        min-height: -webkit-fill-available;
        color: var(--cream);
        overflow-x: hidden;
      }

      /* Texture overlay */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        opacity: 0.03;
        pointer-events: none;
        z-index: 1000;
      }

      /* Main Menu */
      .menu-screen {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 2rem;
        position: relative;
      }

      .logo {
        font-family: "Cinzel", serif;
        font-size: clamp(3rem, 8vw, 6rem);
        font-weight: 900;
        color: var(--gold);
        text-shadow: 0 0 60px rgba(212, 175, 55, 0.5),
          0 4px 8px rgba(0, 0, 0, 0.8);
        letter-spacing: 0.2em;
        margin-bottom: 0.5rem;
        animation: logoGlow 3s ease-in-out infinite alternate;
      }

      @keyframes logoGlow {
        from {
          text-shadow: 0 0 60px rgba(212, 175, 55, 0.5),
            0 4px 8px rgba(0, 0, 0, 0.8);
        }
        to {
          text-shadow: 0 0 100px rgba(212, 175, 55, 0.8),
            0 4px 8px rgba(0, 0, 0, 0.8);
        }
      }

      .subtitle {
        font-family: "Cinzel", serif;
        font-size: 1.2rem;
        color: var(--gold-dark);
        letter-spacing: 0.5em;
        margin-bottom: 3rem;
        text-transform: uppercase;
      }

      .menu-cards {
        display: flex;
        gap: 2rem;
        perspective: 1000px;
        margin-bottom: 3rem;
      }

      .menu-card {
        width: 120px;
        height: 170px;
        background: linear-gradient(
          135deg,
          var(--crimson) 0%,
          var(--crimson-light) 50%,
          var(--crimson) 100%
        );
        border: 3px solid var(--gold);
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Cinzel", serif;
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--gold);
        box-shadow: var(--card-shadow);
        transform: rotateY(calc(var(--i) * 15deg - 22.5deg)) translateZ(20px);
        animation: cardFloat 4s ease-in-out infinite;
        animation-delay: calc(var(--i) * 0.2s);
      }

      @keyframes cardFloat {
        0%,
        100% {
          transform: rotateY(calc(var(--i) * 15deg - 22.5deg)) translateZ(20px)
            translateY(0);
        }
        50% {
          transform: rotateY(calc(var(--i) * 15deg - 22.5deg)) translateZ(20px)
            translateY(-15px);
        }
      }

      .menu-buttons {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: 100%;
        max-width: 400px;
      }

      .menu-btn {
        font-family: "Cinzel", serif;
        font-size: 1.3rem;
        font-weight: 700;
        padding: 1.2rem 2rem;
        border: 2px solid var(--gold);
        background: linear-gradient(
          135deg,
          rgba(212, 175, 55, 0.1) 0%,
          rgba(212, 175, 55, 0.05) 100%
        );
        color: var(--gold);
        cursor: pointer;
        transition: all 0.3s ease;
        letter-spacing: 0.1em;
        position: relative;
        overflow: hidden;
      }

      .menu-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(212, 175, 55, 0.2),
          transparent
        );
        transition: left 0.5s ease;
      }

      .menu-btn:hover::before {
        left: 100%;
      }

      .menu-btn:hover {
        background: linear-gradient(
          135deg,
          rgba(212, 175, 55, 0.3) 0%,
          rgba(212, 175, 55, 0.15) 100%
        );
        transform: scale(1.02);
        box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
      }

      /* Instructions Modal */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 500;
        padding: 1rem;
      }

      .modal-overlay.active {
        display: flex;
      }

      .modal {
        background: linear-gradient(
          135deg,
          var(--velvet-light) 0%,
          var(--velvet) 100%
        );
        border: 2px solid var(--gold);
        border-radius: 10px;
        max-width: 700px;
        max-height: 85vh;
        overflow-y: auto;
        padding: 2rem;
        position: relative;
      }

      .modal h2 {
        font-family: "Cinzel", serif;
        color: var(--gold);
        font-size: 2rem;
        margin-bottom: 1.5rem;
        text-align: center;
        letter-spacing: 0.1em;
      }

      .modal h3 {
        font-family: "Cinzel", serif;
        color: var(--gold-light);
        font-size: 1.2rem;
        margin: 1.5rem 0 0.8rem;
      }

      .modal p,
      .modal li {
        font-size: 1rem;
        line-height: 1.7;
        color: var(--cream);
        margin-bottom: 0.5rem;
      }

      .modal ul {
        list-style: none;
        padding-left: 1rem;
      }

      .modal li::before {
        content: "â™¦";
        color: var(--gold);
        margin-right: 0.5rem;
      }

      .points-table {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
        margin: 1rem 0;
        padding: 1rem;
        background: rgba(212, 175, 55, 0.1);
        border-radius: 8px;
      }

      .points-row {
        display: flex;
        justify-content: space-between;
        padding: 0.3rem 0.5rem;
      }

      .close-modal {
        position: absolute;
        top: 1rem;
        right: 1rem;
        font-size: 2rem;
        color: var(--gold);
        background: none;
        border: none;
        cursor: pointer;
        transition: transform 0.3s;
      }

      .close-modal:hover {
        transform: rotate(90deg);
      }

      /* Setup Screen */
      .setup-screen {
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 2rem;
      }

      .setup-screen.active {
        display: flex;
      }

      .setup-title {
        font-family: "Cinzel", serif;
        font-size: 2.5rem;
        color: var(--gold);
        margin-bottom: 2rem;
      }

      .setup-options {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        width: 100%;
        max-width: 500px;
      }

      .setup-group {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
      }

      .setup-label {
        font-family: "Cinzel", serif;
        font-size: 1.2rem;
        color: var(--gold-light);
      }

      .option-buttons {
        display: flex;
        gap: 1rem;
      }

      .option-btn {
        flex: 1;
        padding: 1rem;
        font-family: "Cinzel", serif;
        font-size: 1.1rem;
        border: 2px solid var(--gold-dark);
        background: transparent;
        color: var(--cream);
        cursor: pointer;
        transition: all 0.3s;
      }

      .option-btn.selected {
        background: var(--gold);
        color: var(--velvet);
        border-color: var(--gold);
      }

      .option-btn:hover:not(.selected) {
        border-color: var(--gold);
        background: rgba(212, 175, 55, 0.1);
      }

      .name-inputs {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
      }

      .name-input {
        padding: 0.8rem 1rem;
        font-family: "Cinzel", serif;
        font-size: 1.1rem;
        background: rgba(0, 0, 0, 0.3);
        border: 2px solid var(--gold-dark);
        color: var(--cream);
        outline: none;
        transition: all 0.3s;
      }

      .name-input:focus {
        border-color: var(--gold);
        box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
      }

      .name-input::placeholder {
        color: rgba(250, 243, 224, 0.5);
      }

      /* Online Lobby Styles */
      .lobby-info {
        width: 100%;
        margin: 1rem 0;
      }

      .lobby-status {
        font-family: "Cinzel", serif;
        font-size: 1.1rem;
        color: var(--gold);
        text-align: center;
        padding: 1rem;
        background: rgba(212, 175, 55, 0.1);
        border: 1px solid var(--gold-dark);
        border-radius: 5px;
        margin-bottom: 1rem;
      }

      .lobby-status.connected {
        color: #4ade80;
        border-color: #4ade80;
        background: rgba(74, 222, 128, 0.1);
      }

      .lobby-status.error {
        color: #f87171;
        border-color: #f87171;
        background: rgba(248, 113, 113, 0.1);
      }

      .lobby-link-container {
        margin: 1.5rem 0;
        padding: 1.5rem;
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid var(--gold);
        border-radius: 10px;
      }

      .link-box {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin: 1rem 0;
        padding: 1rem 1.5rem;
        background: rgba(0, 0, 0, 0.4);
        border: 2px dashed var(--gold);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .link-box:hover {
        background: rgba(212, 175, 55, 0.2);
        border-style: solid;
        transform: scale(1.02);
        box-shadow: 0 0 25px rgba(212, 175, 55, 0.4);
      }

      .link-text {
        flex: 1;
        font-family: "Courier New", monospace;
        font-size: 0.9rem;
        color: var(--gold-light);
        word-break: break-all;
        text-align: left;
        user-select: all;
      }

      .copy-icon {
        font-size: 2rem;
        flex-shrink: 0;
      }

      .link-instruction {
        font-size: 0.9rem;
        color: var(--cream);
        opacity: 0.9;
        margin-top: 0.5rem;
        text-align: center;
      }

      .copy-feedback {
        color: #4ade80;
        font-size: 1.1rem;
        text-align: center;
        margin-top: 1rem;
        padding: 0.5rem;
        background: rgba(74, 222, 128, 0.2);
        border-radius: 5px;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .copy-feedback.show {
        opacity: 1;
      }

      .join-room-box {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }

      .join-room-box .name-input {
        flex: 1;
      }

      .join-btn {
        padding: 0.8rem 1.5rem !important;
        white-space: nowrap;
      }

      .guest-waiting {
        text-align: center;
        padding: 1.5rem;
        font-family: "Cinzel", serif;
        font-size: 1.1rem;
        color: var(--gold);
        background: rgba(212, 175, 55, 0.1);
        border: 1px dashed var(--gold-dark);
        border-radius: 8px;
        margin-top: 1rem;
      }

      .lobby-players {
        width: 100%;
        margin: 1.5rem 0;
      }

      .player-slots-container {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-top: 0.8rem;
      }

      .player-slot {
        display: flex;
        align-items: center;
        gap: 0.8rem;
        padding: 0.8rem 1rem;
        background: rgba(0, 0, 0, 0.3);
        border: 2px solid var(--gold-dark);
        border-radius: 5px;
        transition: all 0.3s;
      }

      .player-slot.hidden {
        display: none;
      }

      .player-slot.ready {
        border-color: #4ade80;
        background: rgba(74, 222, 128, 0.1);
      }

      .player-slot.waiting {
        border-style: dashed;
        opacity: 0.6;
      }

      .player-slot-icon {
        font-size: 1.3rem;
      }

      .player-slot-name {
        flex: 1;
        font-family: "Cinzel", serif;
        font-size: 1rem;
        color: var(--cream);
      }

      .player-slot-status {
        font-size: 0.8rem;
        color: var(--gold-dark);
      }

      .player-slot-status.host {
        color: var(--gold);
        font-weight: 700;
      }

      .player-slot-status.you {
        color: #4ade80;
      }

      .start-game-btn {
        margin-top: 2rem;
        padding: 1.2rem 3rem;
        font-family: "Cinzel", serif;
        font-size: 1.5rem;
        font-weight: 700;
        background: linear-gradient(
          135deg,
          var(--gold) 0%,
          var(--gold-dark) 100%
        );
        color: var(--velvet);
        border: none;
        cursor: pointer;
        transition: all 0.3s;
        letter-spacing: 0.1em;
      }

      .start-game-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 0 40px rgba(212, 175, 55, 0.5);
      }

      /* Game Screen */
      .game-screen {
        display: none;
        flex-direction: column;
        min-height: 100vh;
        padding: 1rem;
      }

      .game-screen.active {
        display: flex;
      }

      /* Scoreboard */
      .scoreboard {
        display: flex;
        justify-content: center;
        gap: 3rem;
        padding: 1rem;
        background: linear-gradient(
          180deg,
          rgba(26, 10, 10, 0.9) 0%,
          transparent 100%
        );
        margin-bottom: 1rem;
      }

      .score-item {
        text-align: center;
      }

      .score-name {
        font-family: "Cinzel", serif;
        font-size: 1rem;
        color: var(--gold-dark);
        letter-spacing: 0.1em;
      }

      .score-lk {
        font-size: 0.75rem;
        color: #4ade80;
        font-weight: 600;
        margin-top: 0.1rem;
      }

      .score-value {
        font-family: "Cinzel", serif;
        font-size: 2rem;
        font-weight: 700;
        color: var(--gold);
      }

      .score-target {
        font-size: 0.9rem;
        color: var(--cream);
        opacity: 0.7;
      }

      /* Game Area */
      .game-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        max-width: 1200px;
        margin: 0 auto;
        width: 100%;
      }

      .player-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
      }

      .player-area.top {
        flex-direction: column-reverse;
      }

      .player-name {
        font-family: "Cinzel", serif;
        font-size: 1.3rem;
        color: var(--gold);
      }

      .deck-info {
        font-size: 0.9rem;
        color: var(--cream);
        opacity: 0.7;
      }

      .player-deck {
        position: relative;
        width: 100px;
        height: 140px;
      }

      .deck-card {
        position: absolute;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          135deg,
          var(--crimson) 0%,
          var(--crimson-light) 100%
        );
        border: 2px solid var(--gold-dark);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .deck-pattern {
        width: 70%;
        height: 80%;
        border: 2px solid var(--gold-dark);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .deck-pattern::after {
        content: "4C";
        font-family: "Cinzel", serif;
        font-size: 1.5rem;
        color: var(--gold-dark);
      }

      /* Table Center */
      .table-center {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2rem;
        padding: 2rem 0;
      }

      .played-cards-area {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        align-items: center;
      }

      .played-row {
        display: flex;
        gap: 0.8rem;
        justify-content: center;
        min-height: 120px;
      }

      .played-row-label {
        font-family: "Cinzel", serif;
        font-size: 0.9rem;
        color: var(--gold-dark);
        text-align: center;
        margin-bottom: 0.3rem;
      }

      /* Cards */
      .card {
        width: 80px;
        height: 112px;
        background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
        border: 2px solid var(--gold);
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-family: "Cinzel", serif;
        position: relative;
        box-shadow: var(--card-shadow);
        transform-style: preserve-3d;
        transition: transform 0.6s;
      }

      .card.back {
        background: linear-gradient(
          135deg,
          var(--crimson) 0%,
          var(--crimson-light) 100%
        );
      }

      .card.back::after {
        content: "4C";
        font-family: "Cinzel", serif;
        font-size: 1.2rem;
        color: var(--gold-dark);
      }

      .card-value {
        font-size: 1.8rem;
        font-weight: 700;
      }

      .card-suit {
        font-size: 2rem;
      }

      .card-corner {
        position: absolute;
        font-size: 0.8rem;
        line-height: 1;
      }

      .card-corner.top {
        top: 5px;
        left: 5px;
      }

      .card-corner.bottom {
        bottom: 5px;
        right: 5px;
        transform: rotate(180deg);
      }

      .card.red {
        color: #c41e3a;
      }

      .card.black {
        color: #1a1a1a;
      }

      /* Card Animation */
      .card.dealing {
        animation: dealCard 0.7s ease-out forwards;
      }

      @keyframes dealCard {
        0% {
          transform: translateY(-100px) translateX(var(--from-deck, 0px))
            rotateZ(-10deg) scale(0.6);
          opacity: 0;
        }
        30% {
          opacity: 1;
          transform: translateY(-30px) translateX(0) rotateZ(5deg) scale(1.1);
        }
        60% {
          transform: translateY(5px) translateX(0) rotateZ(-2deg) scale(1.02);
        }
        100% {
          transform: translateY(0) translateX(0) rotateZ(0) scale(1);
          opacity: 1;
        }
      }

      .card.flip {
        animation: flipCard 0.8s ease-in-out forwards;
      }

      @keyframes flipCard {
        0% {
          transform: rotateY(0);
        }
        50% {
          transform: rotateY(90deg);
        }
        100% {
          transform: rotateY(0);
        }
      }

      /* Card for player 2 (top) - comes from top */
      .player-area.top .card.dealing {
        animation: dealCardFromTop 0.7s ease-out forwards;
      }

      @keyframes dealCardFromTop {
        0% {
          transform: translateY(100px) rotateZ(10deg) scale(0.6);
          opacity: 0;
        }
        30% {
          opacity: 1;
          transform: translateY(30px) rotateZ(-5deg) scale(1.1);
        }
        60% {
          transform: translateY(-5px) rotateZ(2deg) scale(1.02);
        }
        100% {
          transform: translateY(0) rotateZ(0) scale(1);
          opacity: 1;
        }
      }

      /* Card points animation */
      .card-points-popup {
        position: absolute;
        top: -30px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(
          135deg,
          var(--gold) 0%,
          var(--gold-dark) 100%
        );
        color: var(--velvet);
        padding: 0.3rem 0.6rem;
        border-radius: 20px;
        font-family: "Cinzel", serif;
        font-weight: 700;
        font-size: 0.9rem;
        opacity: 0;
        animation: pointsPopup 1.5s ease-out forwards;
        white-space: nowrap;
        z-index: 10;
        box-shadow: 0 4px 15px rgba(212, 175, 55, 0.5);
      }

      @keyframes pointsPopup {
        0% {
          opacity: 0;
          transform: translateX(-50%) translateY(20px) scale(0.5);
        }
        20% {
          opacity: 1;
          transform: translateX(-50%) translateY(0) scale(1.2);
        }
        40% {
          transform: translateX(-50%) translateY(0) scale(1);
        }
        80% {
          opacity: 1;
          transform: translateX(-50%) translateY(0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateX(-50%) translateY(-30px) scale(0.8);
        }
      }

      .card {
        position: relative;
      }

      /* Round Result */
      .round-result {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(
          135deg,
          var(--velvet) 0%,
          var(--velvet-light) 100%
        );
        border: 3px solid var(--gold);
        border-radius: 15px;
        padding: 2rem 3rem;
        text-align: center;
        z-index: 100;
        display: none;
        animation: resultAppear 0.5s ease-out;
      }

      .round-result.active {
        display: block;
      }

      @keyframes resultAppear {
        from {
          transform: translate(-50%, -50%) scale(0.5);
          opacity: 0;
        }
        to {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
      }

      .result-title {
        font-family: "Cinzel", serif;
        font-size: 1.8rem;
        color: var(--gold);
        margin-bottom: 1rem;
      }

      .result-scores {
        display: flex;
        justify-content: center;
        gap: 2rem;
        margin-bottom: 1rem;
      }

      .result-player {
        text-align: center;
      }

      .result-player-name {
        font-size: 1rem;
        color: var(--cream);
      }

      .result-player-points {
        font-family: "Cinzel", serif;
        font-size: 2rem;
        color: var(--gold);
      }

      .result-winner {
        font-family: "Cinzel", serif;
        font-size: 1.5rem;
        color: var(--gold-light);
        margin-top: 1rem;
      }

      .result-penalty {
        color: #ff6b6b;
        font-size: 1rem;
        margin-top: 0.5rem;
      }

      .result-continue-btn {
        margin-top: 1.5rem;
        padding: 0.8rem 2rem;
        font-family: "Cinzel", serif;
        font-size: 1.1rem;
        font-weight: 700;
        background: linear-gradient(
          135deg,
          var(--gold) 0%,
          var(--gold-dark) 100%
        );
        color: var(--velvet);
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
        animation: pulse 2s ease-in-out infinite;
      }

      .result-continue-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 0 25px rgba(212, 175, 55, 0.6);
      }

      @keyframes pulse {
        0%,
        100% {
          box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }
        50% {
          box-shadow: 0 0 25px rgba(212, 175, 55, 0.6);
        }
      }

      /* Live scores display */
      .live-scores {
        position: fixed;
        top: 50%;
        left: 1rem;
        transform: translateY(-50%);
        background: linear-gradient(
          135deg,
          rgba(26, 10, 10, 0.95) 0%,
          rgba(45, 21, 21, 0.95) 100%
        );
        border: 2px solid var(--gold);
        border-radius: 10px;
        padding: 1rem;
        z-index: 40;
        min-width: 120px;
      }

      .live-scores-title {
        font-family: "Cinzel", serif;
        font-size: 0.9rem;
        color: var(--gold);
        text-align: center;
        margin-bottom: 0.8rem;
        letter-spacing: 0.1em;
      }

      .live-score-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.4rem 0;
        border-bottom: 1px solid rgba(212, 175, 55, 0.2);
      }

      .live-score-row:last-child {
        border-bottom: none;
      }

      .live-score-name {
        font-size: 0.85rem;
        color: var(--cream);
      }

      .live-score-value {
        font-family: "Cinzel", serif;
        font-size: 1.1rem;
        font-weight: 700;
        color: var(--gold);
      }

      .live-score-value.updated {
        animation: scoreUpdate 0.5s ease-out;
      }

      @keyframes scoreUpdate {
        0% {
          transform: scale(1);
          color: var(--gold);
        }
        50% {
          transform: scale(1.3);
          color: var(--gold-light);
        }
        100% {
          transform: scale(1);
          color: var(--gold);
        }
      }

      /* Waiting indicator */
      .waiting-indicator {
        display: none;
        text-align: center;
        padding: 1rem;
        background: rgba(212, 175, 55, 0.15);
        border: 2px solid var(--gold);
        border-radius: 10px;
        margin: 1rem auto;
        max-width: 400px;
        animation: waitingPulse 2s ease-in-out infinite;
      }

      .waiting-indicator.active {
        display: block;
      }

      @keyframes waitingPulse {
        0%,
        100% {
          border-color: var(--gold-dark);
        }
        50% {
          border-color: var(--gold-light);
          box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
        }
      }

      .waiting-text {
        font-family: "Cinzel", serif;
        font-size: 1.2rem;
        color: var(--gold);
      }

      .waiting-player {
        color: var(--gold-light);
        font-weight: 700;
      }

      /* Player turn indicator */
      .player-area.active-turn {
        position: relative;
      }

      .turn-label {
        display: none;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        background: var(--gold);
        color: var(--velvet);
        padding: 0.3rem 1rem;
        border-radius: 20px;
        font-family: "Cinzel", serif;
        font-size: 0.9rem;
        font-weight: 700;
        animation: turnBounce 1s ease-in-out infinite;
        z-index: 10;
        white-space: nowrap;
      }

      .player-area.active-turn .turn-label {
        display: block;
      }

      .player-area.top .turn-label {
        bottom: -40px;
      }

      .player-area:not(.top) .turn-label {
        top: -40px;
      }

      @keyframes turnBounce {
        0%,
        100% {
          transform: translateX(-50%) translateY(0);
        }
        50% {
          transform: translateX(-50%) translateY(-5px);
        }
      }

      /* Shuffle animation */
      .shuffle-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 300;
      }

      .shuffle-overlay.active {
        display: flex;
      }

      .shuffle-title {
        font-family: "Cinzel", serif;
        font-size: 2rem;
        color: var(--gold);
        margin-bottom: 2rem;
        text-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
      }

      .shuffle-deck-container {
        position: relative;
        width: 200px;
        height: 280px;
        perspective: 1000px;
      }

      .shuffle-card {
        position: absolute;
        width: 100px;
        height: 140px;
        background: linear-gradient(
          135deg,
          var(--crimson) 0%,
          var(--crimson-light) 100%
        );
        border: 2px solid var(--gold-dark);
        border-radius: 8px;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .shuffle-card::after {
        content: "4C";
        font-family: "Cinzel", serif;
        font-size: 1.5rem;
        color: var(--gold-dark);
      }

      .shuffle-card.shuffling {
        animation: shuffleCard 0.3s ease-in-out;
      }

      @keyframes shuffleCard {
        0% {
          transform: translate(-50%, -50%) rotateY(0) translateX(0);
        }
        25% {
          transform: translate(-50%, -50%) rotateY(15deg) translateX(30px);
        }
        50% {
          transform: translate(-50%, -50%) rotateY(-15deg) translateX(-30px);
        }
        75% {
          transform: translate(-50%, -50%) rotateY(10deg) translateX(20px);
        }
        100% {
          transform: translate(-50%, -50%) rotateY(0) translateX(0);
        }
      }

      /* Deal animation overlay */
      .deal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 250;
        pointer-events: none;
      }

      .deal-overlay.active {
        display: flex;
      }

      .deal-title {
        font-family: "Cinzel", serif;
        font-size: 1.5rem;
        color: var(--gold);
        margin-bottom: 1rem;
      }

      .deal-card {
        position: absolute;
        width: 80px;
        height: 112px;
        background: linear-gradient(
          135deg,
          var(--crimson) 0%,
          var(--crimson-light) 100%
        );
        border: 2px solid var(--gold-dark);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
      }

      .deal-card::after {
        content: "4C";
        font-family: "Cinzel", serif;
        font-size: 1.2rem;
        color: var(--gold-dark);
      }

      .deal-card.dealing-to-p1 {
        animation: dealToPlayer1 0.5s ease-out forwards;
      }

      .deal-card.dealing-to-p2 {
        animation: dealToPlayer2 0.5s ease-out forwards;
      }

      @keyframes dealToPlayer1 {
        0% {
          opacity: 1;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%) scale(0.8);
        }
        100% {
          opacity: 0;
          top: 85%;
          left: 50%;
          transform: translate(-50%, -50%) scale(1);
        }
      }

      @keyframes dealToPlayer2 {
        0% {
          opacity: 1;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%) scale(0.8);
        }
        100% {
          opacity: 0;
          top: 15%;
          left: 50%;
          transform: translate(-50%, -50%) scale(1);
        }
      }

      .deal-counter {
        font-family: "Cinzel", serif;
        font-size: 3rem;
        color: var(--gold);
        margin-top: 1rem;
      }

      @media (max-width: 900px) {
        .live-scores {
          position: static;
          transform: none;
          margin: 0 auto 1rem;
          display: flex;
          gap: 1rem;
          align-items: center;
          padding: 0.5rem 1rem;
        }

        .live-scores-title {
          margin-bottom: 0;
          margin-right: 0.5rem;
        }

        .live-score-row {
          border-bottom: none;
          padding: 0 0.5rem;
          border-right: 1px solid rgba(212, 175, 55, 0.2);
        }

        .live-score-row:last-child {
          border-right: none;
        }
      }

      /* Controls */
      .game-controls {
        display: flex;
        justify-content: center;
        gap: 2rem;
        padding: 1rem;
      }

      .control-btn {
        padding: 1rem 2rem;
        font-family: "Cinzel", serif;
        font-size: 1.1rem;
        background: linear-gradient(
          135deg,
          var(--gold) 0%,
          var(--gold-dark) 100%
        );
        color: var(--velvet);
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .control-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
      }

      .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .control-hint {
        font-size: 0.8rem;
        color: var(--cream);
        opacity: 0.7;
        margin-top: 0.3rem;
        text-align: center;
      }

      /* Help Button */
      .help-btn {
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: var(--gold);
        color: var(--velvet);
        border: none;
        font-family: "Cinzel", serif;
        font-size: 1.5rem;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        transition: all 0.3s;
        z-index: 50;
      }

      .help-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 0 25px rgba(212, 175, 55, 0.5);
      }

      .help-btn.hidden {
        display: none;
      }

      /* Game Over */
      .game-over-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 200;
      }

      .game-over-screen.active {
        display: flex;
      }

      .game-over-content {
        text-align: center;
        animation: gameOverAppear 1s ease-out;
      }

      @keyframes gameOverAppear {
        from {
          transform: scale(0.5);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      .game-over-title {
        font-family: "Cinzel", serif;
        font-size: 4rem;
        color: var(--gold);
        text-shadow: 0 0 60px rgba(212, 175, 55, 0.8);
        margin-bottom: 1rem;
      }

      .game-over-winner {
        font-family: "Cinzel", serif;
        font-size: 2rem;
        color: var(--cream);
        margin-bottom: 2rem;
      }

      .final-scores {
        display: flex;
        justify-content: center;
        gap: 3rem;
        margin-bottom: 2rem;
      }

      .final-score-item {
        text-align: center;
      }

      .final-score-name {
        font-size: 1.2rem;
        color: var(--gold-dark);
      }

      .final-score-value {
        font-family: "Cinzel", serif;
        font-size: 3rem;
        color: var(--gold);
      }

      /* Rematch styles */
      .rematch-section {
        margin: 2rem 0;
        padding: 1.5rem;
        background: rgba(212, 175, 55, 0.1);
        border: 2px solid var(--gold);
        border-radius: 10px;
      }

      .rematch-title {
        font-family: "Cinzel", serif;
        font-size: 1.5rem;
        color: var(--gold);
        margin-bottom: 1rem;
      }

      .rematch-votes {
        margin-bottom: 1rem;
      }

      .vote-status {
        font-size: 1rem;
        color: var(--cream);
      }

      .rematch-buttons {
        display: flex;
        justify-content: center;
        gap: 1.5rem;
        margin: 1rem 0;
      }

      .rematch-btn {
        font-family: "Cinzel", serif;
        font-size: 1.2rem;
        font-weight: 700;
        padding: 1rem 2.5rem;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .rematch-btn.yes {
        background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
        color: #000;
      }

      .rematch-btn.yes:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
      }

      .rematch-btn.no {
        background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
        color: #fff;
      }

      .rematch-btn.no:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(248, 113, 113, 0.5);
      }

      .rematch-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none !important;
      }

      .rematch-btn.selected {
        border: 3px solid #fff;
        transform: scale(1.1);
      }

      .rematch-result {
        font-family: "Cinzel", serif;
        font-size: 1.2rem;
        margin-top: 1rem;
        min-height: 1.5rem;
      }

      .rematch-result.success {
        color: #4ade80;
      }

      .rematch-result.failed {
        color: #f87171;
      }

      .player-vote {
        display: inline-block;
        padding: 0.3rem 0.8rem;
        margin: 0.2rem;
        border-radius: 20px;
        font-size: 0.9rem;
      }

      .player-vote.waiting {
        background: rgba(255, 255, 255, 0.2);
        color: var(--cream);
      }

      .player-vote.yes {
        background: rgba(74, 222, 128, 0.3);
        color: #4ade80;
      }

      .player-vote.no {
        background: rgba(248, 113, 113, 0.3);
        color: #f87171;
      }

      /* Sound button - left corner */
      .sound-btn {
        position: fixed;
        top: 1rem;
        left: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 42px;
        height: 42px;
        padding: 0;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid var(--gold);
        border-radius: 50%;
        color: var(--gold);
        font-size: 1.2rem;
        cursor: pointer;
        transition: all 0.3s;
        z-index: 1000;
      }

      .sound-btn:hover {
        background: rgba(212, 175, 55, 0.2);
        transform: scale(1.05);
      }

      .sound-btn.muted {
        opacity: 0.5;
      }

      /* Account Panel */
      .account-panel {
        background: rgba(0, 0, 0, 0.6);
        border: 2px solid var(--gold);
        border-radius: 15px;
        padding: 1rem 1.5rem;
        margin-bottom: 1.5rem;
        max-width: 200px;
      }

      .account-name-row {
        margin-bottom: 0.8rem;
      }

      .account-name-input {
        width: 100%;
        padding: 0.5rem;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--gold);
        border-radius: 8px;
        color: var(--cream);
        font-family: "Cinzel", serif;
        font-size: 1rem;
        text-align: center;
      }

      .account-name-input::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }

      .account-stats {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-bottom: 0.8rem;
      }

      .account-stat {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.3rem 0;
      }

      .stat-label {
        font-size: 1rem;
        color: var(--gold);
        font-weight: 700;
      }

      .stat-value {
        font-size: 1.2rem;
        font-weight: 700;
        color: var(--cream);
      }

      .stat-bonus {
        display: none;
      }

      .upgrade-btn {
        width: 100%;
        padding: 0.5rem;
        background: linear-gradient(135deg, #4ade80, #22c55e);
        border: none;
        border-radius: 8px;
        color: #000;
        font-family: "Cinzel", serif;
        font-weight: 700;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.3s;
      }

      .upgrade-btn:hover {
        transform: scale(1.02);
        box-shadow: 0 0 15px rgba(74, 222, 128, 0.5);
      }

      /* Upgrade Modal */
      .upgrade-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 2000;
        justify-content: center;
        align-items: center;
      }

      .upgrade-modal.active {
        display: flex;
      }

      .upgrade-content {
        background: linear-gradient(135deg, var(--velvet), #2a1a1a);
        border: 3px solid var(--gold);
        border-radius: 20px;
        padding: 2rem;
        max-width: 400px;
        width: 90%;
        text-align: center;
      }

      .upgrade-title {
        color: var(--gold);
        font-size: 1.5rem;
        margin-bottom: 1.5rem;
      }

      .upgrade-current {
        font-size: 1.2rem;
        color: var(--cream);
        margin-bottom: 1.5rem;
      }

      .upgrade-bonus {
        display: none;
      }

      .upgrade-slider-container {
        margin-bottom: 1.5rem;
      }

      .upgrade-slider-container label {
        display: block;
        color: var(--cream);
        margin-bottom: 0.5rem;
      }

      .upgrade-slider {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        -webkit-appearance: none;
      }

      .upgrade-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: var(--gold);
        cursor: pointer;
      }

      .upgrade-points {
        display: block;
        color: #4ade80;
        font-size: 1.5rem;
        font-weight: 700;
        margin-top: 0.5rem;
      }

      .upgrade-preview {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        padding: 1rem;
        margin-bottom: 1.5rem;
      }

      .upgrade-new,
      .upgrade-cost,
      .upgrade-balance {
        margin: 0.5rem 0;
        color: var(--cream);
      }

      .upgrade-cost span:last-child {
        color: var(--gold);
        font-weight: 700;
      }

      .upgrade-buttons {
        display: flex;
        gap: 1rem;
      }

      .upgrade-confirm-btn,
      .upgrade-cancel-btn {
        flex: 1;
        padding: 0.8rem;
        border: none;
        border-radius: 10px;
        font-family: "Cinzel", serif;
        font-weight: 700;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s;
      }

      .upgrade-confirm-btn {
        background: linear-gradient(135deg, #4ade80, #22c55e);
        color: #000;
      }

      .upgrade-confirm-btn:hover:not(:disabled) {
        transform: scale(1.02);
      }

      .upgrade-confirm-btn:disabled {
        background: #666;
        cursor: not-allowed;
      }

      .upgrade-cancel-btn {
        background: rgba(255, 255, 255, 0.2);
        color: var(--cream);
        border: 1px solid var(--gold);
      }

      /* LK display in game */
      .luck-display {
        font-size: 0.8rem;
        color: #4ade80;
        margin-top: 0.2rem;
      }

      /* LK Slider in setup */
      .luck-slider-group {
        margin-top: 1rem;
      }

      .luck-slider-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }

      .luck-slider {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        -webkit-appearance: none;
      }

      .luck-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #4ade80;
        cursor: pointer;
      }

      .luck-value {
        display: none;
      }

      .luck-input {
        width: 70px;
        padding: 0.3rem;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--gold);
        border-radius: 5px;
        color: var(--cream);
        font-family: "Cinzel", serif;
        text-align: center;
      }

      /* Language button - right corner */
      .lang-btn {
        position: fixed;
        top: 1rem;
        right: 1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid var(--gold);
        border-radius: 25px;
        color: var(--gold);
        font-family: "Cinzel", serif;
        font-size: 0.9rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.3s;
        z-index: 1000;
      }

      .lang-btn:hover {
        background: rgba(212, 175, 55, 0.2);
        transform: scale(1.05);
      }

      .lang-flag {
        font-size: 1.2rem;
      }

      .lang-text {
        letter-spacing: 0.1em;
      }

      /* Surrender button */
      .surrender-btn {
        display: block;
        width: 100%;
        margin-top: 1rem;
        padding: 0.6rem;
        font-family: "Cinzel", serif;
        font-size: 0.8rem;
        background: transparent;
        color: var(--gold-dark);
        border: 1px solid var(--gold-dark);
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s;
        opacity: 0.7;
      }

      .surrender-btn:hover {
        opacity: 1;
        background: rgba(248, 113, 113, 0.2);
        border-color: #f87171;
        color: #f87171;
      }

      /* Surrender modal */
      .surrender-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 300;
      }

      .surrender-modal.active {
        display: flex;
      }

      .surrender-content {
        background: linear-gradient(
          135deg,
          var(--velvet-light) 0%,
          var(--velvet) 100%
        );
        border: 3px solid var(--gold);
        border-radius: 15px;
        padding: 2rem;
        text-align: center;
        max-width: 400px;
        width: 90%;
        animation: modalAppear 0.3s ease-out;
      }

      .surrender-title {
        font-family: "Cinzel", serif;
        font-size: 1.8rem;
        color: var(--gold);
        margin-bottom: 1rem;
      }

      .surrender-text {
        font-size: 1.1rem;
        color: var(--cream);
        margin-bottom: 0.5rem;
      }

      .surrender-buttons {
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        margin-top: 1.5rem;
      }

      .surrender-confirm-btn {
        font-family: "Cinzel", serif;
        font-size: 1rem;
        font-weight: 700;
        padding: 1rem 2rem;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .surrender-confirm-btn.yes {
        background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
        color: #fff;
      }

      .surrender-confirm-btn.yes:hover {
        transform: scale(1.02);
        box-shadow: 0 0 20px rgba(248, 113, 113, 0.5);
      }

      .surrender-confirm-btn.no {
        background: linear-gradient(
          135deg,
          var(--gold) 0%,
          var(--gold-dark) 100%
        );
        color: var(--velvet);
      }

      .surrender-confirm-btn.no:hover {
        transform: scale(1.02);
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
      }

      /* Tiebreaker Indicator */
      .tiebreaker-indicator {
        display: none;
        text-align: center;
        padding: 0.5rem;
        background: rgba(212, 175, 55, 0.2);
        border: 1px solid var(--gold);
        border-radius: 5px;
        margin: 0.5rem 0;
      }

      .tiebreaker-indicator.active {
        display: block;
      }

      .tiebreaker-text {
        font-family: "Cinzel", serif;
        color: var(--gold);
        font-size: 1.1rem;
      }

      /* Responsive */
      @media (max-width: 600px) {
        .card {
          width: 55px;
          height: 77px;
        }

        .card-value {
          font-size: 1.2rem;
        }

        .card-suit {
          font-size: 1.3rem;
        }

        .card-corner {
          font-size: 0.55rem;
          padding: 2px;
        }

        .card-points-popup {
          font-size: 0.7rem;
          padding: 0.2rem 0.4rem;
        }

        .menu-card {
          width: 70px;
          height: 98px;
          font-size: 1.6rem;
        }

        .logo {
          font-size: 2.2rem;
        }

        .subtitle {
          font-size: 1rem;
        }

        .scoreboard {
          gap: 1rem;
          padding: 0.5rem;
        }

        .score-value {
          font-size: 1.3rem;
        }

        .score-name {
          font-size: 0.75rem;
        }

        /* Setup screens */
        .setup-screen {
          padding: 1rem;
        }

        .setup-title {
          font-size: 1.5rem;
        }

        .setup-options {
          padding: 1rem;
          max-width: 100%;
        }

        .setup-label {
          font-size: 0.9rem;
        }

        .option-btn {
          padding: 0.6rem 1rem;
          font-size: 0.85rem;
        }

        .name-input {
          padding: 0.6rem;
          font-size: 0.9rem;
        }

        .menu-btn {
          padding: 0.8rem 1.5rem;
          font-size: 0.95rem;
        }

        .start-game-btn {
          padding: 0.8rem 1.5rem;
          font-size: 1rem;
        }

        /* Online lobby */
        .lobby-link-container {
          padding: 1rem;
        }

        .link-box {
          padding: 0.8rem;
          flex-direction: column;
          gap: 0.5rem;
        }

        .link-text {
          font-size: 0.75rem;
          text-align: center;
        }

        .copy-icon {
          font-size: 1.5rem;
        }

        .link-instruction {
          font-size: 0.8rem;
        }

        .player-slot {
          padding: 0.6rem;
        }

        .player-slot-name {
          font-size: 0.9rem;
        }

        .player-slot-icon {
          font-size: 1.2rem;
        }

        /* Game screen */
        .game-screen {
          padding: 0.5rem;
        }

        .player-area {
          padding: 0.5rem;
        }

        .played-row {
          gap: 0.3rem;
          min-height: 80px;
        }

        .deck-info {
          font-size: 0.75rem;
        }

        .deck-card {
          width: 50px;
          height: 70px;
        }

        .control-btn {
          padding: 0.8rem 1.2rem;
          font-size: 0.9rem;
        }

        .control-hint {
          font-size: 0.7rem;
        }

        /* Live scores mobile */
        .live-scores {
          padding: 0.4rem 0.8rem;
          font-size: 0.8rem;
        }

        .live-scores-title {
          font-size: 0.7rem;
        }

        .live-score-value {
          font-size: 1rem;
        }

        .live-score-name {
          font-size: 0.65rem;
        }

        /* Round result */
        .round-result {
          padding: 1.5rem 1rem;
          width: 95%;
          max-width: 350px;
        }

        .result-title {
          font-size: 1.3rem;
        }

        .result-player-points {
          font-size: 2rem;
        }

        .result-winner {
          font-size: 1rem;
        }

        .result-penalty {
          font-size: 0.85rem;
        }

        .result-continue-btn {
          padding: 0.8rem 2rem;
          font-size: 1rem;
        }

        /* Game over */
        .game-over-content {
          padding: 1rem;
          width: 95%;
        }

        .game-over-title {
          font-size: 2.2rem;
        }

        .game-over-winner {
          font-size: 1.2rem;
        }

        .final-scores {
          gap: 1.5rem;
          flex-wrap: wrap;
        }

        .final-score-value {
          font-size: 2rem;
        }

        .final-score-name {
          font-size: 0.9rem;
        }

        /* Rematch */
        .rematch-section {
          padding: 1rem;
          margin: 1rem 0;
        }

        .rematch-title {
          font-size: 1.2rem;
        }

        .rematch-buttons {
          gap: 1rem;
        }

        .rematch-btn {
          padding: 0.8rem 1.5rem;
          font-size: 1rem;
        }

        .player-vote {
          font-size: 0.75rem;
          padding: 0.2rem 0.5rem;
        }

        /* Instructions modal */
        .instructions-content {
          padding: 1.5rem;
          max-height: 85vh;
          width: 95%;
        }

        .instructions-content h2 {
          font-size: 1.5rem;
        }

        .instructions-content h3 {
          font-size: 1.1rem;
        }

        .points-table {
          font-size: 0.85rem;
        }

        /* Help button */
        .help-btn {
          width: 40px;
          height: 40px;
          font-size: 1.2rem;
          bottom: 0.5rem;
          right: 0.5rem;
        }

        /* Surrender */
        .surrender-btn {
          font-size: 0.75rem;
          padding: 0.5rem;
        }

        .surrender-content {
          padding: 1.5rem;
        }

        .surrender-title {
          font-size: 1.4rem;
        }

        .surrender-text {
          font-size: 0.95rem;
        }

        .surrender-confirm-btn {
          padding: 0.8rem 1.5rem;
          font-size: 0.9rem;
        }

        /* Turn indicator */
        .turn-indicator {
          font-size: 0.9rem;
          padding: 0.4rem 1rem;
        }

        /* Tiebreaker indicator */
        .tiebreaker-indicator {
          font-size: 0.9rem;
          padding: 0.4rem 1rem;
        }

        /* Join room box */
        .join-room-box {
          flex-direction: column;
          gap: 0.5rem;
        }

        .join-btn {
          width: 100%;
        }
      }

      /* Extra small devices */
      @media (max-width: 380px) {
        .card {
          width: 48px;
          height: 67px;
        }

        .card-value {
          font-size: 1rem;
        }

        .card-suit {
          font-size: 1.1rem;
        }

        .logo {
          font-size: 1.8rem;
        }

        .menu-card {
          width: 55px;
          height: 77px;
          font-size: 1.3rem;
        }

        .game-over-title {
          font-size: 1.8rem;
        }

        .rematch-buttons {
          flex-direction: column;
        }

        .rematch-btn {
          width: 100%;
        }
      }

      /* Tablet landscape and desktop */
      @media (min-width: 901px) {
        .game-screen {
          max-width: 1200px;
          margin: 0 auto;
        }

        .played-row {
          gap: 1rem;
        }

        .card {
          width: 90px;
          height: 126px;
        }

        .card-value {
          font-size: 2rem;
        }

        .card-suit {
          font-size: 2.5rem;
        }
      }

      /* Ensure touch targets are large enough */
      @media (pointer: coarse) {
        .option-btn,
        .menu-btn,
        .control-btn,
        .rematch-btn {
          min-height: 48px;
        }

        .link-box {
          min-height: 60px;
        }
      }

      /* Landscape phone */
      @media (max-height: 500px) and (orientation: landscape) {
        .menu-screen {
          padding: 0.5rem;
        }

        .logo {
          font-size: 1.8rem;
          margin-bottom: 0.3rem;
        }

        .subtitle {
          margin-bottom: 0.5rem;
        }

        .menu-cards {
          margin: 0.5rem 0;
        }

        .menu-card {
          width: 50px;
          height: 70px;
          font-size: 1.2rem;
        }

        .player-area {
          padding: 0.3rem;
        }

        .played-row {
          min-height: 70px;
        }

        .game-over-title {
          font-size: 1.5rem;
          margin-bottom: 0.5rem;
        }

        .game-over-winner {
          font-size: 1rem;
          margin-bottom: 0.5rem;
        }

        .final-scores {
          margin-bottom: 0.5rem;
        }

        .final-score-value {
          font-size: 1.5rem;
        }

        .rematch-section {
          padding: 0.5rem;
          margin: 0.5rem 0;
        }
      }
    </style>
  </head>
  <body>
    <!-- Sound Button -->
    <button class="sound-btn" id="soundBtn" onclick="toggleSound()">
      <span class="sound-icon">ðŸ”Š</span>
    </button>

    <!-- Language Button -->
    <button class="lang-btn" id="langBtn" onclick="toggleLanguage()">
      <span class="lang-flag">ðŸ‡µðŸ‡±</span>
      <span class="lang-text">PL</span>
    </button>

    <!-- Menu Screen -->
    <div class="menu-screen" id="menuScreen">
      <h1 class="logo">4 CARDS</h1>
      <p class="subtitle" data-i18n="subtitle">Cztero Karcianka</p>

      <!-- Player Account Panel -->
      <div class="account-panel" id="accountPanel">
        <div class="account-name-row">
          <input
            type="text"
            class="account-name-input"
            id="accountNameInput"
            data-i18n-placeholder="yourNamePlaceholder"
            placeholder="Twoja nazwa..."
            maxlength="12"
            onchange="saveAccountName()"
          />
        </div>
        <div class="account-stats">
          <div class="account-stat">
            <span class="stat-label">LK</span>
            <span class="stat-value" id="accountLuck">0</span>
          </div>
          <div class="account-stat">
            <span class="stat-label">â± </span>
            <span class="stat-value" id="accountMoney">100</span>
          </div>
        </div>
        <button class="upgrade-btn" onclick="showUpgradeModal()">
          â¬†ï¸ <span data-i18n="upgradeLuck">ULEPSZ LK</span>
        </button>
      </div>

      <div class="menu-cards">
        <div class="menu-card" style="--i: 0">A</div>
        <div class="menu-card" style="--i: 1">K</div>
        <div class="menu-card" style="--i: 2">Q</div>
        <div class="menu-card" style="--i: 3">J</div>
      </div>

      <div class="menu-buttons">
        <button
          class="menu-btn"
          onclick="showSetup('local')"
          data-i18n="newLocalGame"
        >
          NOWA GRA LOKALNA
        </button>
        <button
          class="menu-btn"
          onclick="showSetup('online')"
          data-i18n="onlineGame"
        >
          GRA ONLINE
        </button>
        <button
          class="menu-btn"
          onclick="showInstructions()"
          data-i18n="instructions"
        >
          INSTRUKCJA
        </button>
      </div>
    </div>

    <!-- Upgrade LK Modal -->
    <div class="upgrade-modal" id="upgradeModal">
      <div class="upgrade-content">
        <h2 class="upgrade-title">
          â¬†ï¸ <span data-i18n="upgradeLuck">ULEPSZ LK</span>
        </h2>
        <div class="upgrade-current">
          <span data-i18n="currentLK">Aktualny LK:</span>
          <span id="upgradeCurrent">0</span>
        </div>
        <div class="upgrade-slider-container">
          <label data-i18n="pointsToAdd">Punkty do dodania:</label>
          <input
            type="range"
            class="upgrade-slider"
            id="upgradeSlider"
            min="1"
            max="100"
            value="1"
            oninput="updateUpgradePreview()"
          />
          <span class="upgrade-points" id="upgradePoints">+1</span>
        </div>
        <div class="upgrade-preview">
          <div class="upgrade-new">
            <span data-i18n="newLK">Nowy LK:</span>
            <span id="upgradeNew">1</span>
          </div>
          <div class="upgrade-cost">
            <span data-i18n="cost">Koszt:</span>
            <span id="upgradeCost">1</span> â± 
          </div>
          <div class="upgrade-balance">
            <span data-i18n="yourBalance">Twoje â± :</span>
            <span id="upgradeBalance">100</span>
          </div>
        </div>
        <div class="upgrade-buttons">
          <button
            class="upgrade-confirm-btn"
            id="upgradeConfirmBtn"
            onclick="confirmUpgrade()"
            data-i18n="upgrade"
          >
            ULEPSZ
          </button>
          <button
            class="upgrade-cancel-btn"
            onclick="closeUpgradeModal()"
            data-i18n="cancel"
          >
            ANULUJ
          </button>
        </div>
      </div>
    </div>

    <!-- Setup Screen -->
    <div class="setup-screen" id="setupScreen">
      <h2 class="setup-title" data-i18n="gameSettings">USTAWIENIA GRY</h2>

      <div class="setup-options">
        <div class="setup-group" id="modeGroup">
          <label class="setup-label" data-i18n="gameMode">Tryb gry:</label>
          <div class="option-buttons">
            <button
              class="option-btn selected"
              data-option="mode"
              data-value="bot"
              onclick="selectOption(this)"
              data-i18n="vsBot"
            >
              vs BOT
            </button>
            <button
              class="option-btn"
              data-option="mode"
              data-value="local"
              onclick="selectOption(this)"
              data-i18n="twoPlayers"
            >
              2 Graczy (1 PC)
            </button>
          </div>
        </div>

        <div class="setup-group">
          <label class="setup-label" data-i18n="targetScore"
            >Cel punktowy:</label
          >
          <div class="option-buttons">
            <button
              class="option-btn selected"
              data-option="target"
              data-value="2660"
              onclick="selectOption(this)"
            >
              2660 pkt
            </button>
            <button
              class="option-btn"
              data-option="target"
              data-value="3100"
              onclick="selectOption(this)"
            >
              3100 pkt
            </button>
          </div>
        </div>

        <div class="setup-group" id="nameInputs">
          <label class="setup-label" data-i18n="playerName"
            >Nazwa gracza:</label
          >
          <div class="name-inputs">
            <input
              type="text"
              class="name-input"
              id="player1Name"
              data-i18n-placeholder="player1"
              placeholder="Gracz 1"
              maxlength="12"
            />
            <input
              type="text"
              class="name-input"
              id="player2NameInput"
              data-i18n-placeholder="player2"
              placeholder="Gracz 2"
              maxlength="12"
              style="display: none"
            />
          </div>
        </div>

        <!-- LK Settings -->
        <div class="setup-group" id="luckSettings">
          <label class="setup-label" data-i18n="luckLabel"
            >ðŸ€ SzczÄ™Å›cie (LK):</label
          >

          <!-- Player 1 LK (shown in bot mode) -->
          <div class="luck-slider-group" id="player1LuckGroup">
            <div class="luck-slider-row">
              <span id="player1LuckLabel" data-i18n="you">Ty:</span>
              <input
                type="range"
                class="luck-slider"
                id="player1LuckSlider"
                min="0"
                max="2000"
                value="0"
                oninput="updateLuckDisplay(1)"
              />
              <input
                type="number"
                class="luck-input"
                id="player1LuckInput"
                min="0"
                max="2000"
                value="0"
                onchange="updateLuckFromInput(1)"
              />
            </div>
            <div class="luck-value" id="player1LuckBonus"></div>
          </div>

          <!-- Bot/Player 2 LK -->
          <div class="luck-slider-group" id="player2LuckGroup">
            <div class="luck-slider-row">
              <span id="player2LuckLabel">Bot:</span>
              <input
                type="range"
                class="luck-slider"
                id="player2LuckSlider"
                min="0"
                max="2000"
                value="0"
                oninput="updateLuckDisplay(2)"
              />
              <input
                type="number"
                class="luck-input"
                id="player2LuckInput"
                min="0"
                max="2000"
                value="0"
                onchange="updateLuckFromInput(2)"
              />
            </div>
            <div class="luck-value" id="player2LuckBonus"></div>
          </div>
        </div>

        <button
          class="start-game-btn"
          onclick="startGame()"
          data-i18n="startGame"
        >
          ROZPOCZNIJ GRÄ˜
        </button>
        <button
          class="menu-btn"
          style="margin-top: 1rem"
          onclick="backToMenu()"
          data-i18n="back"
        >
          POWRÃ“T
        </button>
      </div>
    </div>

    <!-- Online Lobby Screen -->
    <div class="setup-screen" id="onlineLobby">
      <h2 class="setup-title">GRA ONLINE</h2>

      <div class="setup-options">
        <!-- Initial choice: Create or Join -->
        <div id="onlineChoiceSection">
          <div class="setup-group">
            <label class="setup-label">Twoja nazwa:</label>
            <input
              type="text"
              class="name-input"
              id="onlinePlayerName"
              placeholder="Wpisz nazwÄ™..."
              maxlength="12"
            />
          </div>

          <button
            class="menu-btn"
            style="
              margin-top: 1rem;
              background: var(--gold);
              color: var(--velvet);
            "
            onclick="createRoom()"
          >
            UTWÃ“RZ POKÃ“J
          </button>

          <div class="setup-group" style="margin-top: 2rem">
            <label class="setup-label" data-i18n="joinRoom"
              >Lub doÅ‚Ä…cz do istniejÄ…cego pokoju:</label
            >
            <div class="join-room-box">
              <input
                type="text"
                class="name-input"
                id="joinRoomCode"
                data-i18n-placeholder="enterCodeOrLink"
                placeholder="Wklej link lub kod (np. C4-ABC123)"
                style="text-transform: none"
              />
              <button
                class="menu-btn join-btn"
                onclick="joinRoomFromInput()"
                data-i18n="join"
              >
                DOÅÄ„CZ
              </button>
            </div>
          </div>

          <button
            class="menu-btn"
            style="margin-top: 2rem"
            onclick="backToMenu()"
          >
            POWRÃ“T
          </button>
        </div>

        <!-- Host Lobby -->
        <div id="hostLobbySection" style="display: none">
          <div class="setup-group" id="playerCountGroup">
            <label class="setup-label">Liczba graczy:</label>
            <div class="option-buttons">
              <button
                class="option-btn selected"
                data-option="playerCount"
                data-value="2"
                onclick="selectOption(this); updatePlayerSlots();"
              >
                2 Graczy
              </button>
              <button
                class="option-btn"
                data-option="playerCount"
                data-value="4"
                onclick="selectOption(this); updatePlayerSlots();"
              >
                4 Graczy
              </button>
            </div>
          </div>

          <div class="setup-group">
            <label class="setup-label">Cel punktowy:</label>
            <div class="option-buttons">
              <button
                class="option-btn selected"
                data-option="onlineTarget"
                data-value="2660"
                onclick="selectOption(this)"
              >
                2660 pkt
              </button>
              <button
                class="option-btn"
                data-option="onlineTarget"
                data-value="3100"
                onclick="selectOption(this)"
              >
                3100 pkt
              </button>
            </div>
          </div>

          <div class="lobby-info" id="lobbyInfo">
            <div class="lobby-status" id="lobbyStatus">Tworzenie pokoju...</div>
            <div class="lobby-link-container" id="lobbyLinkContainer">
              <label class="setup-label"
                >ðŸ“Ž Link do gry (kliknij aby skopiowaÄ‡):</label
              >
              <div class="link-box" onclick="copyLink()">
                <span class="link-text" id="lobbyLinkText">Generowanie...</span>
                <span class="copy-icon">ðŸ“‹</span>
              </div>
              <div class="copy-feedback" id="copyFeedback">
                âœ“ Skopiowano link!
              </div>
              <p class="link-instruction">
                WyÅ›lij ten link znajomemu - po otwarciu od razu doÅ‚Ä…czy do gry!
              </p>
            </div>
          </div>

          <div class="lobby-players" id="lobbyPlayers">
            <div class="setup-label">
              Gracze w lobby (<span id="playerCountDisplay">0</span>/<span
                id="maxPlayersDisplay"
                >2</span
              >):
            </div>
            <div class="player-slots-container" id="playerSlotsContainer">
              <div class="player-slot ready" id="playerSlot1">
                <span class="player-slot-icon">ðŸ‘¤</span>
                <span
                  class="player-slot-name"
                  id="lobbyPlayer1Name"
                  data-i18n="waiting"
                  >Oczekiwanie...</span
                >
                <span class="player-slot-status host" id="player1Status"
                  >(Host)</span
                >
              </div>
              <div class="player-slot waiting" id="playerSlot2">
                <span class="player-slot-icon">ðŸ‘¤</span>
                <span
                  class="player-slot-name"
                  id="lobbyPlayer2Name"
                  data-i18n="waiting"
                  >Oczekiwanie...</span
                >
                <span class="player-slot-status" id="player2Status"></span>
              </div>
              <div class="player-slot waiting hidden" id="playerSlot3">
                <span class="player-slot-icon">ðŸ‘¤</span>
                <span
                  class="player-slot-name"
                  id="lobbyPlayer3Name"
                  data-i18n="waiting"
                  >Oczekiwanie...</span
                >
                <span class="player-slot-status" id="player3Status"></span>
              </div>
              <div class="player-slot waiting hidden" id="playerSlot4">
                <span class="player-slot-icon">ðŸ‘¤</span>
                <span
                  class="player-slot-name"
                  id="lobbyPlayer4Name"
                  data-i18n="waiting"
                  >Oczekiwanie...</span
                >
                <span class="player-slot-status" id="player4Status"></span>
              </div>
            </div>
          </div>

          <button
            class="start-game-btn"
            id="startOnlineBtn"
            onclick="startOnlineGame()"
            disabled
          >
            OCZEKIWANIE NA GRACZY...
          </button>
          <button
            class="menu-btn"
            style="margin-top: 1rem"
            onclick="leaveLobby()"
          >
            OPUÅšÄ† LOBBY
          </button>
        </div>

        <!-- Guest Lobby -->
        <div id="guestLobbySection" style="display: none">
          <div
            class="lobby-status"
            id="guestLobbyStatus"
            data-i18n="connectingToRoom"
          >
            ÅÄ…czenie z pokojem...
          </div>

          <button
            class="menu-btn"
            id="retryConnectBtn"
            style="
              display: none;
              margin: 1rem auto;
              background: var(--gold);
              color: var(--velvet);
            "
            onclick="retryConnect()"
            data-i18n="retryConnect"
          >
            SPRÃ“BUJ PONOWNIE
          </button>

          <div class="lobby-players">
            <div class="setup-label" data-i18n="playersInLobby">
              Gracze w lobby:
            </div>
            <div class="player-slots-container" id="guestPlayerSlots">
              <div class="player-slot" id="guestSlot1">
                <span class="player-slot-icon">ðŸ‘¤</span>
                <span
                  class="player-slot-name"
                  id="guestPlayer1Name"
                  data-i18n="host"
                  >Host</span
                >
                <span class="player-slot-status" data-i18n="host">(Host)</span>
              </div>
              <div class="player-slot ready" id="guestSlot2">
                <span class="player-slot-icon">ðŸ‘¤</span>
                <span
                  class="player-slot-name"
                  id="guestPlayer2Name"
                  data-i18n="you"
                  >Ty</span
                >
                <span class="player-slot-status" data-i18n="you">(Ty)</span>
              </div>
            </div>
          </div>

          <div
            class="guest-waiting"
            id="guestWaitingText"
            data-i18n="guestWaiting"
          >
            Oczekiwanie na rozpoczÄ™cie gry przez hosta...
          </div>

          <button
            class="menu-btn"
            style="margin-top: 1rem"
            onclick="leaveLobby()"
            data-i18n="leaveLobby"
          >
            OPUÅšÄ† LOBBY
          </button>
        </div>
      </div>
    </div>

    <!-- Game Screen -->
    <div class="game-screen" id="gameScreen">
      <div class="scoreboard">
        <div class="score-item">
          <div class="score-name" id="player1NameDisplay">GRACZ 1</div>
          <div class="score-lk" id="player1LKDisplay">LK: 0</div>
          <div class="score-value" id="score1">0</div>
        </div>
        <div class="score-item">
          <div class="score-target">
            Cel: <span id="targetDisplay">2660</span>
          </div>
        </div>
        <div class="score-item">
          <div class="score-name" id="player2Name">BOT</div>
          <div class="score-lk" id="player2LKDisplay">LK: 0</div>
          <div class="score-value" id="score2">0</div>
        </div>
      </div>

      <div class="tiebreaker-indicator" id="tiebreakerIndicator">
        <span class="tiebreaker-text">âš”ï¸ DOGRYWKA! âš”ï¸</span>
      </div>

      <div class="game-area">
        <!-- Player 2 (Top) -->
        <div class="player-area top">
          <span class="turn-label" id="turnLabel2"
            >ðŸ‘‡ <span data-i18n="yourTurn">TWOJA KOLEJ!</span></span
          >
          <div class="player-deck" id="deck2">
            <div class="deck-card">
              <div class="deck-pattern"></div>
            </div>
          </div>
          <div class="deck-info">
            <span data-i18n="cardsInDeck">Kart w talii:</span>
            <span id="deckCount2">12</span>
          </div>
          <div class="played-row" id="playedCards2"></div>
        </div>

        <!-- Table Center -->
        <div class="table-center">
          <div class="waiting-indicator" id="waitingIndicator">
            <span class="waiting-text"
              ><span data-i18n="waitingFor">Oczekiwanie na</span>
              <span class="waiting-player" id="waitingPlayerName">Gracza</span
              >...</span
            >
          </div>

          <div class="game-controls">
            <div id="player1ControlWrapper">
              <button
                class="control-btn"
                id="playBtn1"
                onclick="playCards(1)"
                data-i18n="playCards"
              >
                WYSTAW KARTY
              </button>
              <div class="control-hint" data-i18n="player1Key">
                Gracz 1: Spacja
              </div>
            </div>
            <div id="player2Controls" style="display: none">
              <button
                class="control-btn"
                id="playBtn2"
                onclick="playCards(2)"
                data-i18n="playCards"
              >
                WYSTAW KARTY
              </button>
              <div class="control-hint" data-i18n="player2Key">Gracz 2: â†‘</div>
            </div>
          </div>
        </div>

        <!-- Player 1 (Bottom) -->
        <div class="player-area">
          <span class="turn-label" id="turnLabel1"
            >ðŸ‘† <span data-i18n="yourTurn">TWOJA KOLEJ!</span></span
          >
          <div class="played-row" id="playedCards1"></div>
          <div class="deck-info">
            <span data-i18n="cardsInDeck">Kart w talii:</span>
            <span id="deckCount1">12</span>
          </div>
          <div class="player-deck" id="deck1">
            <div class="deck-card">
              <div class="deck-pattern"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Round Result Popup -->
    <div class="round-result" id="roundResult">
      <div class="result-title" id="resultTitle" data-i18n="roundResult">
        WYNIK RUNDY
      </div>
      <div class="result-scores">
        <div class="result-player">
          <div class="result-player-name" id="resultPlayer1Name">Gracz 1</div>
          <div class="result-player-points" id="roundPoints1">0</div>
        </div>
        <div class="result-player">
          <div class="result-player-name" id="resultPlayer2Name">Bot</div>
          <div class="result-player-points" id="roundPoints2">0</div>
        </div>
      </div>
      <div class="result-winner" id="resultWinner"></div>
      <div class="result-penalty" id="resultPenalty"></div>
      <button
        class="result-continue-btn"
        id="resultContinueBtn"
        onclick="continueGame()"
        data-i18n="continue"
      >
        DALEJ
      </button>
    </div>

    <!-- Live Scores -->
    <div class="live-scores" id="liveScores" style="display: none">
      <div class="live-scores-title" data-i18n="results">WYNIKI</div>
      <div class="live-score-row">
        <span class="live-score-name" id="livePlayer1Name">Gracz 1</span>
        <span class="live-score-value" id="liveScore1">0</span>
      </div>
      <div class="live-score-row">
        <span class="live-score-name" id="livePlayer2Name">Bot</span>
        <span class="live-score-value" id="liveScore2">0</span>
      </div>
      <div
        class="live-score-row"
        style="
          margin-top: 0.5rem;
          padding-top: 0.5rem;
          border-top: 1px solid var(--gold);
        "
      >
        <span class="live-score-name" data-i18n="target">Cel</span>
        <span class="live-score-value" id="liveTarget" style="font-size: 0.9rem"
          >2660</span
        >
      </div>
      <button
        class="surrender-btn"
        id="surrenderBtn"
        onclick="confirmSurrender()"
        data-i18n="surrender"
      >
        ðŸ³ï¸ PODDAJ SIÄ˜
      </button>
    </div>

    <!-- Surrender Confirmation -->
    <div class="surrender-modal" id="surrenderModal">
      <div class="surrender-content">
        <h2 class="surrender-title" data-i18n="surrenderConfirm">
          ðŸ³ï¸ PODDAÄ† SIÄ˜?
        </h2>
        <p class="surrender-text" data-i18n="surrenderQuestion">
          Czy na pewno chcesz siÄ™ poddaÄ‡?
        </p>
        <p
          class="surrender-text"
          id="surrenderOnlineInfo"
          style="display: none"
          data-i18n="surrenderOnlineInfo"
        >
          Przeciwnik wygra, ale bÄ™dziesz mÃ³gÅ‚ zaproponowaÄ‡ rewanÅ¼.
        </p>
        <div class="surrender-buttons">
          <button
            class="surrender-confirm-btn yes"
            onclick="surrender()"
            data-i18n="yesSurrender"
          >
            TAK, PODDAJÄ˜ SIÄ˜
          </button>
          <button
            class="surrender-confirm-btn no"
            onclick="closeSurrenderModal()"
            data-i18n="noKeepPlaying"
          >
            NIE, GRAM DALEJ
          </button>
        </div>
      </div>
    </div>

    <!-- Instructions Modal -->
    <div class="modal-overlay" id="instructionsModal">
      <div class="modal">
        <button class="close-modal" onclick="closeInstructions()">Ã—</button>
        <h2>ðŸ“œ INSTRUKCJA GRY</h2>

        <h3>ðŸŽ¯ Cel gry</h3>
        <p>
          ZdobÄ…dÅº jak najwiÄ™kszÄ… liczbÄ™ punktÃ³w. Gra toczy siÄ™ do 2660 lub 3100
          punktÃ³w.
        </p>

        <h3>ðŸƒ WartoÅ›Ä‡ kart</h3>
        <div class="points-table">
          <div class="points-row"><span>As (A)</span><span>250 pkt</span></div>
          <div class="points-row">
            <span>KrÃ³l (K)</span><span>200 pkt</span>
          </div>
          <div class="points-row">
            <span>KrÃ³lowa (Q)</span><span>150 pkt</span>
          </div>
          <div class="points-row">
            <span>Jupek (J)</span><span>50 pkt</span>
          </div>
          <div class="points-row">
            <span>DziesiÄ…tka (10)</span><span>10 pkt</span>
          </div>
          <div class="points-row">
            <span>DziewiÄ…tka (9)</span><span>5 pkt</span>
          </div>
        </div>

        <h3>ðŸŽ® Przebieg rundy</h3>
        <ul>
          <li>KaÅ¼dy gracz wystawia 4 karty na stÃ³Å‚</li>
          <li>Karty sÄ… odkrywane od razu</li>
          <li>Gracz z wiÄ™kszÄ… liczbÄ… punktÃ³w wygrywa rundÄ™</li>
          <li>ZwyciÄ™zca zabiera punkty swoje ORAZ przeciwnika</li>
        </ul>

        <h3>âš ï¸ Punkty karne</h3>
        <ul>
          <li>Przegrana runda = odejmowanie wÅ‚asnych punktÃ³w z tej rundy</li>
          <li>Punkty nie spadajÄ… poniÅ¼ej zera</li>
        </ul>

        <h3>âš”ï¸ Dogrywka</h3>
        <ul>
          <li>Przy remisie - kaÅ¼dy wyciÄ…ga 2 karty</li>
          <li>Kolejny remis - kaÅ¼dy wyciÄ…ga 1 kartÄ™</li>
          <li>Dogrywki trwajÄ… aÅ¼ do rozstrzygniÄ™cia</li>
        </ul>

        <h3>ðŸ”„ Brak kart</h3>
        <ul>
          <li>
            Gdy skoÅ„czÄ… ci siÄ™ karty, przeciwnik daje ci 4 karty z gÃ³ry swojej
            talii
          </li>
        </ul>

        <h3>ðŸŽ¹ Sterowanie</h3>
        <ul>
          <li><strong>Gracz 1:</strong> Spacja lub klik przycisku</li>
          <li>
            <strong>Gracz 2:</strong> StrzaÅ‚ka w gÃ³rÄ™ (â†‘) lub klik przycisku
          </li>
        </ul>
      </div>
    </div>

    <!-- Game Over Screen -->
    <div class="game-over-screen" id="gameOverScreen">
      <div class="game-over-content">
        <h1 class="game-over-title" data-i18n="gameOver">KONIEC GRY!</h1>
        <p class="game-over-winner" id="gameWinner"></p>
        <div class="final-scores">
          <div class="final-score-item">
            <div class="final-score-name" id="finalPlayer1Name">Gracz 1</div>
            <div class="final-score-value" id="finalScore1">0</div>
          </div>
          <div class="final-score-item">
            <div class="final-score-name" id="finalPlayer2Name">Bot</div>
            <div class="final-score-value" id="finalScore2">0</div>
          </div>
        </div>

        <!-- Rematch section for online mode -->
        <div class="rematch-section" id="rematchSection" style="display: none">
          <div class="rematch-title" data-i18n="playAgain">
            Zagraj ponownie?
          </div>
          <div class="rematch-votes" id="rematchVotes">
            <span
              class="vote-status"
              id="voteStatus"
              data-i18n="waitingForVotes"
              >Oczekiwanie na gÅ‚osy...</span
            >
          </div>
          <div class="rematch-buttons">
            <button
              class="rematch-btn yes"
              id="rematchYesBtn"
              onclick="voteRematch(true)"
            >
              âœ“ <span data-i18n="yes">TAK</span>
            </button>
            <button
              class="rematch-btn no"
              id="rematchNoBtn"
              onclick="voteRematch(false)"
            >
              âœ— <span data-i18n="no">NIE</span>
            </button>
          </div>
          <div class="rematch-result" id="rematchResult"></div>
        </div>

        <button
          class="menu-btn"
          id="backToMenuBtn"
          onclick="backToMenu()"
          data-i18n="backToMenu"
        >
          POWRÃ“T DO MENU
        </button>
      </div>
    </div>

    <!-- Help Button (hidden during game) -->
    <button class="help-btn" id="helpBtn" onclick="showInstructions()">
      ?
    </button>

    <!-- Shuffle Overlay -->
    <div class="shuffle-overlay" id="shuffleOverlay">
      <h2 class="shuffle-title" data-i18n="shuffling">TASOWANIE KART...</h2>
      <div class="shuffle-deck-container">
        <div class="shuffle-card" id="shuffleCard1"></div>
        <div
          class="shuffle-card"
          id="shuffleCard2"
          style="transform: translate(-48%, -48%)"
        ></div>
        <div
          class="shuffle-card"
          id="shuffleCard3"
          style="transform: translate(-52%, -52%)"
        ></div>
      </div>
    </div>

    <!-- Deal Overlay -->
    <div class="deal-overlay" id="dealOverlay">
      <h2 class="deal-title" id="dealTitle">ROZDAWANIE KART</h2>
      <div class="deal-counter" id="dealCounter">24</div>
    </div>

    <script>
      // ==================== TRANSLATIONS ====================
      const translations = {
        pl: {
          subtitle: "Cztero Karcianka",
          newLocalGame: "NOWA GRA LOKALNA",
          onlineGame: "GRA ONLINE",
          instructions: "INSTRUKCJA",
          gameSettings: "USTAWIENIA GRY",
          gameMode: "Tryb gry:",
          vsBot: "vs BOT",
          twoPlayers: "2 Graczy (1 PC)",
          targetScore: "Cel punktowy:",
          playerName: "Nazwa gracza:",
          player1: "Gracz 1",
          player2: "Gracz 2",
          startGame: "ROZPOCZNIJ GRÄ˜",
          back: "POWRÃ“T",
          yourName: "Twoja nazwa:",
          enterName: "Wpisz nazwÄ™...",
          createRoom: "UTWÃ“RZ POKÃ“J",
          joinRoom: "Lub doÅ‚Ä…cz do istniejÄ…cego pokoju:",
          enterRoomCode: "Wpisz kod pokoju (np. C4-ABC123)",
          enterCodeOrLink: "Wklej link lub kod (np. C4-ABC123)",
          join: "DOÅÄ„CZ",
          playerCount: "Liczba graczy:",
          players: "Graczy",
          creatingRoom: "Tworzenie pokoju...",
          roomCreated: "PokÃ³j utworzony! Skopiuj link:",
          roomReady: "PokÃ³j gotowy! WyÅ›lij link znajomym:",
          linkLabel: "ðŸ“Ž Link do gry (kliknij aby skopiowaÄ‡):",
          linkCopied: "âœ“ Skopiowano link!",
          linkInstruction:
            "WyÅ›lij ten link znajomemu - po otwarciu od razu doÅ‚Ä…czy do gry!",
          playersInLobby: "Gracze w lobby",
          waiting: "Oczekiwanie...",
          host: "(Host)",
          hostYou: "(Host - Ty)",
          you: "(Ty)",
          waitingForPlayers: "OCZEKIWANIE NA GRACZY...",
          leaveLobby: "OPUÅšÄ† LOBBY",
          connectingToRoom: "ÅÄ…czenie z pokojem...",
          connectedWaitingHost: "PoÅ‚Ä…czono! Oczekiwanie na hosta...",
          hostDisconnected: "Host rozÅ‚Ä…czyÅ‚ siÄ™",
          roomFull: "PokÃ³j jest peÅ‚ny!",
          connectionError: "BÅ‚Ä…d poÅ‚Ä…czenia",
          retryConnect: "SPRÃ“BUJ PONOWNIE",
          roomNotFound: "PokÃ³j nie istnieje lub host siÄ™ rozÅ‚Ä…czyÅ‚",
          playCards: "WYSTAW KARTY",
          player1Key: "Gracz 1: Spacja",
          player2Key: "Gracz 2: â†‘",
          cardsInDeck: "Kart w talii:",
          roundResult: "WYNIK RUNDY",
          continue: "DALEJ",
          results: "WYNIKI",
          target: "Cel",
          surrender: "ðŸ³ï¸ PODDAJ SIÄ˜",
          surrenderConfirm: "ðŸ³ï¸ PODDAÄ† SIÄ˜?",
          surrenderQuestion: "Czy na pewno chcesz siÄ™ poddaÄ‡?",
          surrenderOnlineInfo:
            "Przeciwnik wygra, ale bÄ™dziesz mÃ³gÅ‚ zaproponowaÄ‡ rewanÅ¼.",
          yesSurrender: "TAK, PODDAJÄ˜ SIÄ˜",
          noKeepPlaying: "NIE, GRAM DALEJ",
          gameOver: "KONIEC GRY!",
          winsGame: "wygrywa grÄ™!",
          surrendered: "poddaÅ‚/a siÄ™!",
          playAgain: "Zagraj ponownie?",
          waitingForVotes: "Oczekiwanie na gÅ‚osy...",
          yes: "TAK",
          no: "NIE",
          rematchRejected: "RewanÅ¼ odrzucony - ktoÅ› nie chce graÄ‡ dalej",
          rematchAccepted: "Wszyscy zgodni! Zaczynamy nowÄ… grÄ™...",
          backToMenu: "POWRÃ“T DO MENU",
          tiebreaker: "âš”ï¸ DOGRYWKA!",
          winsRound: "wygrywa rundÄ™!",
          loses: "traci",
          pts: "pkt",
          instructionsTitle: "ðŸ“œ INSTRUKCJA GRY",
          goal: "ðŸŽ¯ Cel gry",
          goalText: "ZdobÄ…dÅº",
          goalTextEnd: "punktÃ³w jako pierwszy!",
          cardValues: "ðŸƒ WartoÅ›ci kart",
          ace: "As (A)",
          king: "KrÃ³l (K)",
          queen: "KrÃ³lowa (Q)",
          jack: "Jupek (J)",
          ten: "DziesiÄ…tka (10)",
          nine: "DziewiÄ…tka (9)",
          roundFlow: "ðŸŽ® Przebieg rundy",
          roundFlowList: [
            "KaÅ¼dy gracz wystawia 4 karty na stÃ³Å‚",
            "Karty sÄ… odkrywane od razu",
            "Gracz z wiÄ™kszÄ… liczbÄ… punktÃ³w wygrywa rundÄ™",
            "ZwyciÄ™zca zabiera punkty swoje ORAZ przeciwnika",
          ],
          penaltyPoints: "âš ï¸ Punkty karne",
          penaltyList: [
            "Przegrana runda = odejmowanie wÅ‚asnych punktÃ³w z tej rundy",
            "Punkty nie spadajÄ… poniÅ¼ej zera",
          ],
          tiebreakerTitle: "âš”ï¸ Dogrywka",
          tiebreakerList: [
            "Przy remisie - kaÅ¼dy wyciÄ…ga 2 karty",
            "Kolejny remis - kaÅ¼dy wyciÄ…ga 1 kartÄ™",
            "Dogrywki trwajÄ… aÅ¼ do rozstrzygniÄ™cia",
          ],
          noCards: "ðŸ”„ Brak kart",
          noCardsList: [
            "Gdy skoÅ„czÄ… ci siÄ™ karty, przeciwnik daje ci 4 karty z gÃ³ry swojej talii",
          ],
          controls: "ðŸŽ¹ Sterowanie",
          controlsList: [
            "Gracz 1: Spacja lub klik przycisku",
            "Gracz 2: StrzaÅ‚ka w gÃ³rÄ™ (â†‘) lub klik przycisku",
          ],
          waitingFor: "Oczekiwanie na",
          yourTurn: "Twoja kolej!",
          guestWaiting: "Oczekiwanie na rozpoczÄ™cie gry przez hosta...",
          dealing: "ROZDAWANIE KART",
          shuffling: "TASOWANIE KART...",
          // LK System
          luck: "SzczÄ™Å›cie",
          upgradeLuck: "ULEPSZ LK",
          currentLK: "Aktualny LK:",
          pointsToAdd: "Punkty do dodania:",
          newLK: "Nowy LK:",
          cost: "Koszt:",
          yourBalance: "Twoje â± :",
          upgrade: "ULEPSZ",
          cancel: "ANULUJ",
          luckLabel: "ðŸ€ SzczÄ™Å›cie (LK):",
          yourNamePlaceholder: "Twoja nazwa...",
        },
        en: {
          subtitle: "Four Cards Game",
          newLocalGame: "NEW LOCAL GAME",
          onlineGame: "ONLINE GAME",
          instructions: "INSTRUCTIONS",
          gameSettings: "GAME SETTINGS",
          gameMode: "Game mode:",
          vsBot: "vs BOT",
          twoPlayers: "2 Players (1 PC)",
          targetScore: "Target score:",
          playerName: "Player name:",
          player1: "Player 1",
          player2: "Player 2",
          startGame: "START GAME",
          back: "BACK",
          yourName: "Your name:",
          enterName: "Enter name...",
          createRoom: "CREATE ROOM",
          joinRoom: "Or join an existing room:",
          enterRoomCode: "Enter room code (e.g. C4-ABC123)",
          enterCodeOrLink: "Paste link or code (e.g. C4-ABC123)",
          join: "JOIN",
          playerCount: "Number of players:",
          players: "Players",
          creatingRoom: "Creating room...",
          roomCreated: "Room created! Copy the link:",
          roomReady: "Room ready! Send link to friends:",
          linkLabel: "ðŸ“Ž Game link (click to copy):",
          linkCopied: "âœ“ Link copied!",
          linkInstruction:
            "Send this link to a friend - they will join instantly!",
          playersInLobby: "Players in lobby",
          waiting: "Waiting...",
          host: "(Host)",
          hostYou: "(Host - You)",
          you: "(You)",
          waitingForPlayers: "WAITING FOR PLAYERS...",
          leaveLobby: "LEAVE LOBBY",
          connectingToRoom: "Connecting to room...",
          connectedWaitingHost: "Connected! Waiting for host...",
          hostDisconnected: "Host disconnected",
          roomFull: "Room is full!",
          connectionError: "Connection error",
          retryConnect: "TRY AGAIN",
          roomNotFound: "Room does not exist or host disconnected",
          playCards: "PLAY CARDS",
          player1Key: "Player 1: Space",
          player2Key: "Player 2: â†‘",
          cardsInDeck: "Cards in deck:",
          roundResult: "ROUND RESULT",
          continue: "CONTINUE",
          results: "RESULTS",
          target: "Target",
          surrender: "ðŸ³ï¸ SURRENDER",
          surrenderConfirm: "ðŸ³ï¸ SURRENDER?",
          surrenderQuestion: "Are you sure you want to surrender?",
          surrenderOnlineInfo:
            "Your opponent will win, but you can propose a rematch.",
          yesSurrender: "YES, I SURRENDER",
          noKeepPlaying: "NO, KEEP PLAYING",
          gameOver: "GAME OVER!",
          winsGame: "wins the game!",
          surrendered: "surrendered!",
          playAgain: "Play again?",
          waitingForVotes: "Waiting for votes...",
          yes: "YES",
          no: "NO",
          rematchRejected:
            "Rematch rejected - someone doesn't want to continue",
          rematchAccepted: "Everyone agreed! Starting new game...",
          backToMenu: "BACK TO MENU",
          tiebreaker: "âš”ï¸ TIEBREAKER!",
          winsRound: "wins the round!",
          loses: "loses",
          pts: "pts",
          instructionsTitle: "ðŸ“œ GAME INSTRUCTIONS",
          goal: "ðŸŽ¯ Goal",
          goalText: "Be the first to reach",
          goalTextEnd: "points!",
          cardValues: "ðŸƒ Card Values",
          ace: "Ace (A)",
          king: "King (K)",
          queen: "Queen (Q)",
          jack: "Jack (J)",
          ten: "Ten (10)",
          nine: "Nine (9)",
          roundFlow: "ðŸŽ® Round Flow",
          roundFlowList: [
            "Each player plays 4 cards on the table",
            "Cards are revealed immediately",
            "Player with more points wins the round",
            "Winner takes their points AND opponent's points",
          ],
          penaltyPoints: "âš ï¸ Penalty Points",
          penaltyList: [
            "Losing a round = subtracting your own points from that round",
            "Points cannot go below zero",
          ],
          tiebreakerTitle: "âš”ï¸ Tiebreaker",
          tiebreakerList: [
            "On tie - each player draws 2 cards",
            "Another tie - each player draws 1 card",
            "Tiebreakers continue until resolved",
          ],
          noCards: "ðŸ”„ No Cards",
          noCardsList: [
            "When you run out of cards, opponent gives you 4 cards from top of their deck",
          ],
          controls: "ðŸŽ¹ Controls",
          controlsList: [
            "Player 1: Space or click button",
            "Player 2: Arrow up (â†‘) or click button",
          ],
          waitingFor: "Waiting for",
          yourTurn: "Your turn!",
          guestWaiting: "Waiting for host to start the game...",
          dealing: "DEALING CARDS",
          shuffling: "SHUFFLING CARDS...",
          // LK System
          luck: "Luck",
          upgradeLuck: "UPGRADE LK",
          currentLK: "Current LK:",
          pointsToAdd: "Points to add:",
          newLK: "New LK:",
          cost: "Cost:",
          yourBalance: "Your â± :",
          upgrade: "UPGRADE",
          cancel: "CANCEL",
          luckLabel: "ðŸ€ Luck (LK):",
          yourNamePlaceholder: "Your name...",
        },
      };

      let currentLang = "pl";

      function toggleLanguage() {
        currentLang = currentLang === "pl" ? "en" : "pl";
        updateLanguageButton();
        updateLanguage();

        // Save preference
        try {
          localStorage.setItem("4cards-lang", currentLang);
        } catch (e) {}
      }

      function updateLanguageButton() {
        const langBtn = document.getElementById("langBtn");
        if (currentLang === "pl") {
          langBtn.innerHTML =
            '<span class="lang-flag">ðŸ‡µðŸ‡±</span><span class="lang-text">PL</span>';
        } else {
          langBtn.innerHTML =
            '<span class="lang-flag">ðŸ‡¬ðŸ‡§</span><span class="lang-text">EN</span>';
        }
      }

      function updateLanguage() {
        const t = translations[currentLang];

        // Update all elements with data-i18n attribute
        document.querySelectorAll("[data-i18n]").forEach((el) => {
          const key = el.getAttribute("data-i18n");
          if (t[key]) {
            el.textContent = t[key];
          }
        });

        // Update placeholders
        document.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
          const key = el.getAttribute("data-i18n-placeholder");
          if (t[key]) {
            el.placeholder = t[key];
          }
        });
      }

      function t(key) {
        return translations[currentLang][key] || key;
      }

      // Load saved language preference on startup
      (function loadLanguage() {
        try {
          const savedLang = localStorage.getItem("4cards-lang");
          if (savedLang && (savedLang === "pl" || savedLang === "en")) {
            currentLang = savedLang;
          }
        } catch (e) {}
      })();

      // Apply translations and button state after DOM loads
      document.addEventListener("DOMContentLoaded", function () {
        updateLanguageButton();
        updateLanguage();
      });

      // ==================== PLAYER ACCOUNT SYSTEM ====================
      const PlayerAccount = {
        name: "",
        luck: 0, // LK points (affects card draw)
        money: 100, // â±  currency

        load() {
          try {
            const saved = localStorage.getItem("4cards-account");
            if (saved) {
              const data = JSON.parse(saved);
              this.name = data.name || "";
              this.luck = data.luck || 0;
              this.money = data.money || 100;
            }
          } catch (e) {}
        },

        save() {
          try {
            localStorage.setItem(
              "4cards-account",
              JSON.stringify({
                name: this.name,
                luck: this.luck,
                money: this.money,
              })
            );
          } catch (e) {}
        },

        // Calculate upgrade cost - exponential scaling
        getUpgradeCost(currentLK, pointsToAdd) {
          let totalCost = 0;
          for (let i = 0; i < pointsToAdd; i++) {
            const level = currentLK + i;
            // Cost formula: starts at 1, increases exponentially
            totalCost += Math.floor(1 + Math.pow(level / 50, 2));
          }
          return totalCost;
        },

        // Upgrade luck if can afford
        upgradeLuck(points) {
          const cost = this.getUpgradeCost(this.luck, points);
          if (this.money >= cost && this.luck + points <= 2000) {
            this.money -= cost;
            this.luck += points;
            this.save();
            return true;
          }
          return false;
        },

        // Add money from winning
        addMoney(amount) {
          this.money += amount;
          this.save();
        },

        // Remove money from losing (can't go below 0)
        removeMoney(amount) {
          this.money = Math.max(0, this.money - amount);
          this.save();
        },
      };

      // Load account on start
      PlayerAccount.load();

      // ==================== LUCK SYSTEM ====================
      const LuckSystem = {
        // Convert LK to percentage bonus
        // 0 LK = 0%, 500 LK = 25%, 1000 LK = 50%, 2000 LK = 80%
        getLuckBonus(lk) {
          // Linear scaling with soft cap
          return Math.min(80, lk / 25);
        },

        // Apply luck when drawing cards - higher LK = better cards go to top of deck
        applyLuckToDeck(deck, luck) {
          if (luck <= 0) return deck;

          const bonus = this.getLuckBonus(luck) / 100; // Convert to 0-0.8

          // Sort deck by points (highest first)
          const sorted = [...deck].sort((a, b) => b.points - a.points);
          const result = [];

          // For each card, decide if we pick from top (good) or random
          for (let i = 0; i < deck.length; i++) {
            if (sorted.length === 0) break;

            const roll = Math.random();

            if (roll < bonus && sorted.length > 1) {
              // Pick from top 25% of remaining cards (better cards)
              const topCount = Math.max(1, Math.floor(sorted.length * 0.25));
              const idx = Math.floor(Math.random() * topCount);
              result.push(sorted.splice(idx, 1)[0]);
            } else {
              // Pick randomly from remaining
              const idx = Math.floor(Math.random() * sorted.length);
              result.push(sorted.splice(idx, 1)[0]);
            }
          }

          return result;
        },

        // Calculate money earned from winning (online only)
        // You get the difference between opponent's LK and your LK
        calculateWinnings(winnerLK, loserLK) {
          // You earn the difference (if opponent has more LK, you earn more)
          const diff = loserLK - winnerLK;
          // Minimum 1 â± , plus the difference if positive
          return Math.max(1, diff);
        },
      };

      // Update account display
      function updateAccountDisplay() {
        const nameInput = document.getElementById("accountNameInput");
        if (nameInput) {
          nameInput.value = PlayerAccount.name;
        }
        const luckEl = document.getElementById("accountLuck");
        if (luckEl) luckEl.textContent = PlayerAccount.luck;
        const moneyEl = document.getElementById("accountMoney");
        if (moneyEl) moneyEl.textContent = PlayerAccount.money;
        const bonusEl = document.getElementById("accountLuckBonus");
        if (bonusEl)
          bonusEl.textContent = `(+${LuckSystem.getLuckBonus(
            PlayerAccount.luck
          ).toFixed(1)}%)`;
      }

      function saveAccountName() {
        PlayerAccount.name = document
          .getElementById("accountNameInput")
          .value.trim();
        PlayerAccount.save();
      }

      // Upgrade modal functions
      function showUpgradeModal() {
        document.getElementById("upgradeModal").classList.add("active");
        document.getElementById("upgradeCurrent").textContent =
          PlayerAccount.luck;
        document.getElementById("upgradeBalance").textContent =
          PlayerAccount.money;

        // Set slider max based on what player can afford and max LK
        const maxAffordable = Math.min(2000 - PlayerAccount.luck, 500);
        document.getElementById("upgradeSlider").max = Math.max(
          1,
          maxAffordable
        );
        document.getElementById("upgradeSlider").value = 1;

        updateUpgradePreview();
      }

      function closeUpgradeModal() {
        document.getElementById("upgradeModal").classList.remove("active");
      }

      function updateUpgradePreview() {
        const points = parseInt(document.getElementById("upgradeSlider").value);
        const newLK = PlayerAccount.luck + points;
        const cost = PlayerAccount.getUpgradeCost(PlayerAccount.luck, points);

        document.getElementById("upgradePoints").textContent = `+${points}`;
        document.getElementById("upgradeNew").textContent = newLK;
        document.getElementById("upgradeCost").textContent = cost;

        const canAfford = PlayerAccount.money >= cost && newLK <= 2000;
        document.getElementById("upgradeConfirmBtn").disabled = !canAfford;
      }

      function confirmUpgrade() {
        const points = parseInt(document.getElementById("upgradeSlider").value);
        if (PlayerAccount.upgradeLuck(points)) {
          SoundManager.play("win");
          updateAccountDisplay();
          closeUpgradeModal();
        }
      }

      // LK slider functions in setup
      function updateLuckDisplay(playerNum) {
        const slider = document.getElementById(`player${playerNum}LuckSlider`);
        const input = document.getElementById(`player${playerNum}LuckInput`);
        const bonus = document.getElementById(`player${playerNum}LuckBonus`);

        if (!slider || !input || !bonus) return;

        const value = parseInt(slider.value);
        input.value = value;
        bonus.textContent = `(+${LuckSystem.getLuckBonus(value).toFixed(1)}% ${
          currentLang === "pl" ? "szans" : "chance"
        })`;
      }

      function updateLuckFromInput(playerNum) {
        const slider = document.getElementById(`player${playerNum}LuckSlider`);
        const input = document.getElementById(`player${playerNum}LuckInput`);
        const bonus = document.getElementById(`player${playerNum}LuckBonus`);

        if (!slider || !input || !bonus) return;

        let value = parseInt(input.value) || 0;
        value = Math.max(0, Math.min(2000, value));

        slider.value = value;
        input.value = value;
        bonus.textContent = `(+${LuckSystem.getLuckBonus(value).toFixed(1)}% ${
          currentLang === "pl" ? "szans" : "chance"
        })`;
      }

      function initLuckSliders() {
        // Set player 1 slider to their actual LK
        const p1Slider = document.getElementById("player1LuckSlider");
        const p1Input = document.getElementById("player1LuckInput");
        if (p1Slider && p1Input) {
          p1Slider.value = PlayerAccount.luck;
          p1Slider.max = Math.max(PlayerAccount.luck, 2000);
          p1Input.value = PlayerAccount.luck;
          updateLuckDisplay(1);
        }

        // Player 2 / Bot starts at 0
        const p2Slider = document.getElementById("player2LuckSlider");
        const p2Input = document.getElementById("player2LuckInput");
        if (p2Slider && p2Input) {
          p2Slider.value = 0;
          p2Input.value = 0;
          updateLuckDisplay(2);
        }
      }

      // Initialize account display on DOMContentLoaded
      document.addEventListener("DOMContentLoaded", function () {
        updateAccountDisplay();
      });

      // ==================== SOUND SYSTEM ====================
      const SoundManager = {
        ctx: null,
        enabled: true,

        init() {
          try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          } catch (e) {
            console.log("Audio not supported");
          }
        },

        resume() {
          if (this.ctx && this.ctx.state === "suspended") {
            this.ctx.resume();
          }
        },

        play(type) {
          if (!this.enabled || !this.ctx) return;
          this.resume();

          const now = this.ctx.currentTime;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.connect(gain);
          gain.connect(this.ctx.destination);

          switch (type) {
            case "card":
              // Card flip sound - short click
              osc.type = "sine";
              osc.frequency.setValueAtTime(800, now);
              osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
              gain.gain.setValueAtTime(0.3, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
              osc.start(now);
              osc.stop(now + 0.05);
              break;

            case "win":
              // Win round - happy ascending
              osc.type = "sine";
              osc.frequency.setValueAtTime(523, now); // C5
              osc.frequency.setValueAtTime(659, now + 0.1); // E5
              osc.frequency.setValueAtTime(784, now + 0.2); // G5
              gain.gain.setValueAtTime(0.3, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
              osc.start(now);
              osc.stop(now + 0.4);
              break;

            case "lose":
              // Lose round - sad descending
              osc.type = "sine";
              osc.frequency.setValueAtTime(400, now);
              osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
              gain.gain.setValueAtTime(0.3, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
              osc.start(now);
              osc.stop(now + 0.3);
              break;

            case "tie":
              // Tie - two quick beeps
              osc.type = "square";
              osc.frequency.setValueAtTime(440, now);
              gain.gain.setValueAtTime(0.2, now);
              gain.gain.setValueAtTime(0, now + 0.1);
              gain.gain.setValueAtTime(0.2, now + 0.15);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
              osc.start(now);
              osc.stop(now + 0.25);
              break;

            case "gameWin":
              // Game win - victory fanfare
              osc.type = "sine";
              osc.frequency.setValueAtTime(523, now);
              osc.frequency.setValueAtTime(659, now + 0.15);
              osc.frequency.setValueAtTime(784, now + 0.3);
              osc.frequency.setValueAtTime(1047, now + 0.45);
              gain.gain.setValueAtTime(0.4, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.7);
              osc.start(now);
              osc.stop(now + 0.7);
              break;

            case "gameLose":
              // Game lose - sad trombone
              osc.type = "sawtooth";
              osc.frequency.setValueAtTime(300, now);
              osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
              gain.gain.setValueAtTime(0.2, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
              osc.start(now);
              osc.stop(now + 0.5);
              break;

            case "click":
              // Button click
              osc.type = "sine";
              osc.frequency.setValueAtTime(600, now);
              gain.gain.setValueAtTime(0.2, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
              osc.start(now);
              osc.stop(now + 0.03);
              break;

            case "shuffle":
              // Shuffle cards
              osc.type = "noise" in osc ? "noise" : "sawtooth";
              osc.frequency.setValueAtTime(100, now);
              gain.gain.setValueAtTime(0.1, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
              osc.start(now);
              osc.stop(now + 0.2);
              break;

            case "join":
              // Player joined
              osc.type = "sine";
              osc.frequency.setValueAtTime(440, now);
              osc.frequency.setValueAtTime(880, now + 0.1);
              gain.gain.setValueAtTime(0.3, now);
              gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
              osc.start(now);
              osc.stop(now + 0.2);
              break;
          }
        },
      };

      // Initialize sound on first interaction
      document.addEventListener("click", () => SoundManager.init(), {
        once: true,
      });
      document.addEventListener("keydown", () => SoundManager.init(), {
        once: true,
      });

      function toggleSound() {
        SoundManager.enabled = !SoundManager.enabled;
        const btn = document.getElementById("soundBtn");
        if (SoundManager.enabled) {
          btn.innerHTML = '<span class="sound-icon">ðŸ”Š</span>';
          btn.classList.remove("muted");
        } else {
          btn.innerHTML = '<span class="sound-icon">ðŸ”‡</span>';
          btn.classList.add("muted");
        }
        // Save preference
        try {
          localStorage.setItem(
            "4cards-sound",
            SoundManager.enabled ? "on" : "off"
          );
        } catch (e) {}
      }

      // Load sound preference
      try {
        const savedSound = localStorage.getItem("4cards-sound");
        if (savedSound === "off") {
          SoundManager.enabled = false;
          document.addEventListener("DOMContentLoaded", () => {
            document.getElementById("soundBtn").innerHTML =
              '<span class="sound-icon">ðŸ”‡</span>';
            document.getElementById("soundBtn").classList.add("muted");
          });
        }
      } catch (e) {}

      // Game State
      const gameState = {
        mode: "bot", // 'bot' or 'local' or 'online'
        targetScore: 2660,
        scores: [0, 0],
        decks: [[], []],
        playedCards: [[], []],
        roundPoints: [0, 0],
        cardsToPlay: 4,
        playersReady: [false, false],
        inRound: false,
        inTiebreaker: false,
        tiebreakerLevel: 0,
        tiebreakerPot: [],
        wonCardsPile: [],
        gameOver: false,
        playerNames: ["Gracz 1", "BOT"],
        playerLuck: [0, 0], // LK for each player
        currentTurn: 1,
        waitingForSecondPlayer: false,
        isProcessingPlay: false,
        isAnimating: false,
      };

      // Card definitions - standard deck from 9 up (9, 10, J, Q, K, A)
      // ONE shared deck: 6 values x 4 suits = 24 cards total, split between players (12 each)
      const CARD_VALUES = {
        A: 250,
        K: 200,
        Q: 150,
        J: 50,
        10: 10,
        9: 5,
      };

      const SUITS = ["â™ ", "â™¥", "â™¦", "â™£"];
      const VALUES = ["A", "K", "Q", "J", "10", "9"];
      const TOTAL_CARDS = 24; // Total cards in the deck
      const CARDS_PER_PLAYER = 12; // Each player gets half

      // Create a single deck - each card appears exactly once
      function createDeck() {
        const deck = [];
        for (const suit of SUITS) {
          for (const value of VALUES) {
            deck.push({
              value,
              suit,
              points: CARD_VALUES[value],
              id: `${value}${suit}`,
            });
          }
        }
        return shuffleDeck(deck);
      }

      // Deal cards to both players from a single shuffled deck
      function dealCards() {
        const fullDeck = createDeck();
        let deck1 = fullDeck.slice(0, CARDS_PER_PLAYER); // First 12 cards to player 1
        let deck2 = fullDeck.slice(CARDS_PER_PLAYER); // Last 12 cards to player 2

        // Apply luck to decks - higher LK = better card arrangement
        deck1 = LuckSystem.applyLuckToDeck(deck1, gameState.playerLuck[0]);
        deck2 = LuckSystem.applyLuckToDeck(deck2, gameState.playerLuck[1]);

        gameState.decks[0] = deck1;
        gameState.decks[1] = deck2;
      }

      // Shuffle deck
      function shuffleDeck(deck) {
        for (let i = deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
      }

      // UI Functions
      function showSetup() {
        document.getElementById("menuScreen").style.display = "none";
        document.getElementById("setupScreen").classList.add("active");
      }

      function backToMenu() {
        // Cleanup online connection if exists
        if (onlineState.conn) {
          onlineState.conn.close();
        }
        if (onlineState.peer) {
          onlineState.peer.destroy();
        }
        onlineState.peer = null;
        onlineState.conn = null;
        onlineState.isHost = false;
        onlineState.roomId = null;

        document.getElementById("menuScreen").style.display = "flex";
        document.getElementById("setupScreen").classList.remove("active");
        document.getElementById("onlineLobby").classList.remove("active");
        document.getElementById("gameScreen").classList.remove("active");
        document.getElementById("gameOverScreen").classList.remove("active");
        document.getElementById("helpBtn").classList.remove("hidden");
        document.getElementById("liveScores").style.display = "none";

        // Reset lobby UI
        document.getElementById("lobbyStatus").textContent = t("creatingRoom");
        document
          .getElementById("lobbyStatus")
          .classList.remove("connected", "error");
        document.getElementById("lobbyPlayer1Name").textContent = t("waiting");
        document.getElementById("lobbyPlayer2Name").textContent = t("waiting");
        document.getElementById("startOnlineBtn").disabled = true;
        document.getElementById("startOnlineBtn").textContent =
          t("waitingForPlayers");
      }

      function selectOption(btn) {
        const option = btn.dataset.option;
        const value = btn.dataset.value;

        // Deselect siblings
        btn.parentElement
          .querySelectorAll(".option-btn")
          .forEach((b) => b.classList.remove("selected"));
        btn.classList.add("selected");

        if (option === "mode") {
          gameState.mode = value;
          // Show/hide second player name input
          const player2Input = document.getElementById("player2NameInput");
          const player2LuckLabel = document.getElementById("player2LuckLabel");

          if (value === "local") {
            player2Input.style.display = "block";
            if (player2LuckLabel)
              player2LuckLabel.textContent =
                currentLang === "pl" ? "Gracz 2:" : "Player 2:";
          } else {
            player2Input.style.display = "none";
            if (player2LuckLabel) player2LuckLabel.textContent = "Bot:";
          }
        } else if (option === "target") {
          gameState.targetScore = parseInt(value);
        }
      }

      function showInstructions() {
        document.getElementById("instructionsModal").classList.add("active");
      }

      function closeInstructions() {
        document.getElementById("instructionsModal").classList.remove("active");
      }

      // Game Functions
      function startGame() {
        // Get player names
        const name1Input = document.getElementById("player1Name").value.trim();
        const name2Input = document
          .getElementById("player2NameInput")
          .value.trim();

        gameState.playerNames[0] = name1Input || t("player1");
        gameState.playerNames[1] =
          gameState.mode === "bot" ? "BOT" : name2Input || t("player2");

        // Get LK values from sliders
        const p1Luck =
          parseInt(document.getElementById("player1LuckInput").value) || 0;
        const p2Luck =
          parseInt(document.getElementById("player2LuckInput").value) || 0;
        gameState.playerLuck = [p1Luck, p2Luck];

        // Reset game state
        gameState.scores = [0, 0];
        gameState.decks = [[], []]; // Will be filled after shuffle animation
        gameState.playedCards = [[], []];
        gameState.roundPoints = [0, 0];
        gameState.cardsToPlay = 4;
        gameState.playersReady = [false, false];
        gameState.inRound = false;
        gameState.inTiebreaker = false;
        gameState.tiebreakerLevel = 0;
        gameState.tiebreakerPot = [];
        gameState.gameOver = false;
        gameState.currentTurn = 1;
        gameState.waitingForSecondPlayer = false;
        gameState.tiebreakerPot = []; // Reset tiebreaker pot

        // Update UI
        document.getElementById("setupScreen").classList.remove("active");
        document.getElementById("helpBtn").classList.add("hidden");

        // Update all name displays
        document.getElementById("player1NameDisplay").textContent =
          gameState.playerNames[0];
        document.getElementById("player2Name").textContent =
          gameState.playerNames[1];
        document.getElementById("resultPlayer1Name").textContent =
          gameState.playerNames[0];
        document.getElementById("resultPlayer2Name").textContent =
          gameState.playerNames[1];
        document.getElementById("finalPlayer1Name").textContent =
          gameState.playerNames[0];
        document.getElementById("finalPlayer2Name").textContent =
          gameState.playerNames[1];
        document.getElementById("livePlayer1Name").textContent =
          gameState.playerNames[0];
        document.getElementById("livePlayer2Name").textContent =
          gameState.playerNames[1];

        // Update LK displays
        document.getElementById(
          "player1LKDisplay"
        ).textContent = `LK: ${gameState.playerLuck[0]}`;
        document.getElementById(
          "player2LKDisplay"
        ).textContent = `LK: ${gameState.playerLuck[1]}`;

        document.getElementById("targetDisplay").textContent =
          gameState.targetScore;
        document.getElementById("liveTarget").textContent =
          gameState.targetScore;

        // Start shuffle animation
        startShuffleAnimation();
      }

      function startShuffleAnimation() {
        SoundManager.play("shuffle");
        const shuffleOverlay = document.getElementById("shuffleOverlay");
        shuffleOverlay.classList.add("active");

        const cards = [
          document.getElementById("shuffleCard1"),
          document.getElementById("shuffleCard2"),
          document.getElementById("shuffleCard3"),
        ];

        let shuffleCount = 0;
        const maxShuffles = 8;

        const shuffleInterval = setInterval(() => {
          cards.forEach((card, index) => {
            setTimeout(() => {
              card.classList.remove("shuffling");
              void card.offsetWidth; // Trigger reflow
              card.classList.add("shuffling");
            }, index * 100);
          });

          shuffleCount++;
          if (shuffleCount >= maxShuffles) {
            clearInterval(shuffleInterval);
            setTimeout(() => {
              shuffleOverlay.classList.remove("active");
              // Create and deal cards from single deck
              dealCards();
              startDealAnimation();
            }, 500);
          }
        }, 400);
      }

      function startDealAnimation() {
        const dealOverlay = document.getElementById("dealOverlay");
        const dealCounter = document.getElementById("dealCounter");
        const dealTitle = document.getElementById("dealTitle");

        dealOverlay.classList.add("active");
        dealTitle.textContent = t("dealing");

        let cardsDealt = 0;
        const totalCardsToShow = TOTAL_CARDS; // 24 cards total
        let currentPlayer = 0; // Alternate between players

        dealCounter.textContent = CARDS_PER_PLAYER; // Start at 12

        const dealInterval = setInterval(() => {
          // Create flying card
          const card = document.createElement("div");
          card.className = "deal-card";
          card.classList.add(
            currentPlayer === 0 ? "dealing-to-p1" : "dealing-to-p2"
          );
          dealOverlay.appendChild(card);

          // Remove card after animation
          setTimeout(() => {
            card.remove();
          }, 500);

          cardsDealt++;
          // Update counter - shows cards remaining for each player
          dealCounter.textContent =
            CARDS_PER_PLAYER - Math.ceil(cardsDealt / 2);

          // Alternate players
          currentPlayer = 1 - currentPlayer;

          if (cardsDealt >= totalCardsToShow) {
            clearInterval(dealInterval);
            setTimeout(() => {
              dealOverlay.classList.remove("active");
              // Now show game screen
              document.getElementById("gameScreen").classList.add("active");
              document.getElementById("liveScores").style.display = "block";

              // Setup controls for local mode
              if (gameState.mode === "local") {
                document.getElementById("player2Controls").style.display =
                  "none";
                document.getElementById("player1ControlWrapper").style.display =
                  "block";
                updateTurnIndicator();
              } else {
                document.getElementById("player2Controls").style.display =
                  "none";
                document.getElementById("player1ControlWrapper").style.display =
                  "block";
              }

              updateDisplay();
            }, 300);
          }
        }, 80);
      }

      function updateTurnIndicator() {
        const player1Area = document.querySelector(".player-area:not(.top)");
        const player2Area = document.querySelector(".player-area.top");
        const waitingIndicator = document.getElementById("waitingIndicator");

        player1Area.classList.remove("active-turn");
        player2Area.classList.remove("active-turn");
        waitingIndicator.classList.remove("active");

        if (gameState.mode !== "local") return;

        if (gameState.waitingForSecondPlayer) {
          // Player 1 played, waiting for player 2
          player2Area.classList.add("active-turn");
          document.getElementById("player1ControlWrapper").style.display =
            "none";
          document.getElementById("player2Controls").style.display = "block";
          document.getElementById("playBtn2").disabled = false;
        } else if (!gameState.playersReady[0]) {
          // Waiting for player 1
          player1Area.classList.add("active-turn");
          document.getElementById("player1ControlWrapper").style.display =
            "block";
          document.getElementById("player2Controls").style.display = "none";
          document.getElementById("playBtn1").disabled = false;
        }
      }

      function updateDisplay() {
        document.getElementById("score1").textContent = gameState.scores[0];
        document.getElementById("score2").textContent = gameState.scores[1];
        document.getElementById("deckCount1").textContent =
          gameState.decks[0].length;
        document.getElementById("deckCount2").textContent =
          gameState.decks[1].length;

        // Update live scores with animation
        const liveScore1 = document.getElementById("liveScore1");
        const liveScore2 = document.getElementById("liveScore2");

        if (liveScore1.textContent !== String(gameState.scores[0])) {
          liveScore1.textContent = gameState.scores[0];
          liveScore1.classList.remove("updated");
          void liveScore1.offsetWidth; // Trigger reflow
          liveScore1.classList.add("updated");
        }

        if (liveScore2.textContent !== String(gameState.scores[1])) {
          liveScore2.textContent = gameState.scores[1];
          liveScore2.classList.remove("updated");
          void liveScore2.offsetWidth; // Trigger reflow
          liveScore2.classList.add("updated");
        }

        // Update deck visibility
        document.getElementById("deck1").style.opacity =
          gameState.decks[0].length > 0 ? 1 : 0.3;
        document.getElementById("deck2").style.opacity =
          gameState.decks[1].length > 0 ? 1 : 0.3;
      }

      function playCards(playerNum) {
        const playerIndex = playerNum - 1;

        // Basic guards
        if (gameState.gameOver) return;
        if (gameState.playersReady[playerIndex]) return;

        // In online mode, only allow playing as yourself
        if (gameState.mode === "online") {
          const myIndex = onlineState.myPlayerIndex;
          if (gameState.playersReady[myIndex]) return;

          checkAndTransferCards(myIndex);

          const cardsNeeded = gameState.cardsToPlay;
          if (gameState.decks[myIndex].length < cardsNeeded) return;

          // Draw cards
          const drawnCards = gameState.decks[myIndex].splice(0, cardsNeeded);
          gameState.playedCards[myIndex] = drawnCards;
          gameState.playersReady[myIndex] = true;

          // Disable button
          document.getElementById("playBtn1").disabled = true;

          // Display cards
          displayPlayedCards(myIndex, drawnCards);
          updateDisplay();

          // Send to all other players
          const message = {
            type: "playCards",
            playerIndex: myIndex,
            cards: drawnCards,
            remainingDeck: gameState.decks[myIndex],
          };

          if (onlineState.isHost) {
            broadcastToAll(message);
          } else if (onlineState.connections.length > 0) {
            onlineState.connections[0].send(message);
          }

          // Check round end after animation
          setTimeout(function () {
            checkRoundEnd();
          }, gameState.cardsToPlay * 500 + 500);
          return;
        }

        // In local mode, enforce turn order
        if (gameState.mode === "local") {
          if (playerNum === 1 && gameState.waitingForSecondPlayer) return;
          if (playerNum === 2 && !gameState.waitingForSecondPlayer) return;
        }

        // Check if player needs cards from opponent
        checkAndTransferCards(playerIndex);

        const cardsNeeded = gameState.cardsToPlay;
        if (gameState.decks[playerIndex].length < cardsNeeded) {
          return;
        }

        // Draw cards
        const drawnCards = gameState.decks[playerIndex].splice(0, cardsNeeded);
        gameState.playedCards[playerIndex] = drawnCards;
        gameState.playersReady[playerIndex] = true;

        // Disable button
        document.getElementById(`playBtn${playerNum}`).disabled = true;

        // Display cards with animation
        displayPlayedCards(playerIndex, drawnCards);
        updateDisplay();

        if (gameState.mode === "bot") {
          // Bot plays after animation
          setTimeout(function () {
            botPlay();
          }, gameState.cardsToPlay * 500 + 1000);
        } else if (gameState.mode === "local") {
          if (playerNum === 1) {
            gameState.waitingForSecondPlayer = true;
            setTimeout(function () {
              updateTurnIndicator();
            }, gameState.cardsToPlay * 500 + 800);
          } else {
            gameState.waitingForSecondPlayer = false;
            setTimeout(function () {
              checkRoundEnd();
            }, gameState.cardsToPlay * 500 + 500);
          }
        }
      }

      function checkAndTransferCards(playerIndex) {
        const maxPlayers = gameState.maxPlayers || 2;
        const cardsNeeded = gameState.cardsToPlay;

        if (gameState.decks[playerIndex].length >= cardsNeeded) return true;

        if (maxPlayers === 2) {
          // 2 players: get cards from opponent
          const opponentIndex = 1 - playerIndex;
          const opponentCards = gameState.decks[opponentIndex].length;

          if (opponentCards >= 4) {
            // Transfer 4 cards
            const transferCards = gameState.decks[opponentIndex].splice(0, 4);
            gameState.decks[playerIndex].push(...transferCards);
            updateDisplay();
            return true;
          } else if (opponentCards > 0) {
            // Transfer all remaining cards
            const transferCards = gameState.decks[opponentIndex].splice(
              0,
              opponentCards
            );
            gameState.decks[playerIndex].push(...transferCards);
            updateDisplay();
            return gameState.decks[playerIndex].length >= cardsNeeded;
          } else {
            // No cards to transfer - check if we still have enough
            return gameState.decks[playerIndex].length >= cardsNeeded;
          }
        } else {
          // 4 players: get cards from wonCardsPile
          if (gameState.wonCardsPile.length >= 4) {
            const transferCards = gameState.wonCardsPile.splice(0, 4);
            gameState.decks[playerIndex].push(...transferCards);
            updateDisplay();
            return true;
          } else if (gameState.wonCardsPile.length > 0) {
            const transferCards = gameState.wonCardsPile.splice(
              0,
              gameState.wonCardsPile.length
            );
            gameState.decks[playerIndex].push(...transferCards);
            updateDisplay();
            return gameState.decks[playerIndex].length >= cardsNeeded;
          }
          return gameState.decks[playerIndex].length >= cardsNeeded;
        }
      }

      function displayPlayedCards(playerIndex, cards) {
        const containerId = `playedCards${playerIndex + 1}`;
        const container = document.getElementById(containerId);
        container.innerHTML = "";

        cards.forEach((card, index) => {
          setTimeout(() => {
            SoundManager.play("card");
            const cardEl = createCardElement(card);
            cardEl.classList.add("dealing");
            container.appendChild(cardEl);

            // Show points popup after card lands
            setTimeout(() => {
              const pointsPopup = document.createElement("div");
              pointsPopup.className = "card-points-popup";
              pointsPopup.textContent = `+${card.points} ${t("pts")}`;
              cardEl.appendChild(pointsPopup);
            }, 700);
          }, index * 500); // Slower card dealing - 500ms between cards
        });
      }

      function createCardElement(card) {
        const cardEl = document.createElement("div");
        const isRed = card.suit === "â™¥" || card.suit === "â™¦";
        cardEl.className = `card ${isRed ? "red" : "black"}`;

        cardEl.innerHTML = `
                <div class="card-corner top">${card.value}<br>${card.suit}</div>
                <div class="card-value">${card.value}</div>
                <div class="card-suit">${card.suit}</div>
                <div class="card-corner bottom">${card.value}<br>${card.suit}</div>
            `;

        return cardEl;
      }

      function botPlay() {
        if (gameState.playersReady[1]) return;

        checkAndTransferCards(1);

        const cardsNeeded = gameState.cardsToPlay;
        if (gameState.decks[1].length < cardsNeeded) return;

        const drawnCards = gameState.decks[1].splice(0, cardsNeeded);
        gameState.playedCards[1] = drawnCards;
        gameState.playersReady[1] = true;

        displayPlayedCards(1, drawnCards);
        updateDisplay();

        checkRoundEnd();
      }

      function checkRoundEnd() {
        if (!gameState.playersReady[0] || !gameState.playersReady[1]) return;

        // Wait for all card animations to complete
        const totalCards = gameState.cardsToPlay;
        const animationTime = totalCards * 500 + 1800; // card dealing (500ms each) + points popup

        setTimeout(() => {
          calculateRoundResult();
        }, animationTime);
      }

      function calculateRoundResult() {
        const maxPlayers = gameState.maxPlayers || 2;

        // Calculate points for all players
        const points = [];
        for (let i = 0; i < maxPlayers; i++) {
          points[i] = gameState.playedCards[i].reduce(
            (sum, card) => sum + card.points,
            0
          );
        }

        gameState.roundPoints = points;

        // Display result (for 2 players)
        document.getElementById("roundPoints1").textContent = points[0];
        document.getElementById("roundPoints2").textContent = points[1] || 0;

        let resultTitle = t("roundResult");
        let winner = "";
        let penalty = "";

        // Collect all played cards from this round
        let thisRoundCards = [];
        for (let i = 0; i < maxPlayers; i++) {
          thisRoundCards.push(...gameState.playedCards[i]);
        }

        // Add to tiebreaker pot
        const allCardsToWin = [...gameState.tiebreakerPot, ...thisRoundCards];
        const totalPotPoints = allCardsToWin.reduce(
          (sum, card) => sum + card.points,
          0
        );

        // Find winner(s) - highest points
        const maxPoints = Math.max(...points);
        const winners = points
          .map((p, i) => (p === maxPoints ? i : -1))
          .filter((i) => i >= 0);

        if (winners.length === 1) {
          // Single winner
          const winnerIndex = winners[0];
          const winnerName = gameState.playerNames[winnerIndex];

          if (maxPlayers === 2) {
            // 2 players: winner takes cards to their deck
            gameState.decks[winnerIndex].push(...allCardsToWin);

            // Loser loses their points
            const loserIndex = 1 - winnerIndex;
            gameState.scores[loserIndex] = Math.max(
              0,
              gameState.scores[loserIndex] - points[loserIndex]
            );
            penalty = `${gameState.playerNames[loserIndex]} ${t("loses")} ${
              points[loserIndex]
            } ${t("pts")}`;
          } else {
            // 4 players: cards go to separate pile
            gameState.wonCardsPile.push(...allCardsToWin);

            // All losers lose their points
            for (let i = 0; i < maxPlayers; i++) {
              if (i !== winnerIndex) {
                gameState.scores[i] = Math.max(
                  0,
                  gameState.scores[i] - points[i]
                );
              }
            }
            penalty =
              currentLang === "pl"
                ? "Przegrani tracÄ… swoje punkty"
                : "Losers lose their points";
          }

          gameState.scores[winnerIndex] += totalPotPoints;
          winner = `ðŸ† ${winnerName} ${t("winsRound")}`;
          gameState.tiebreakerPot = [];
          resetTiebreaker();

          // Play sound and award/deduct money based on who won (ONLINE ONLY)
          const myIndex =
            gameState.mode === "online" ? onlineState.myPlayerIndex : 0;
          const opponentIndex = 1 - myIndex;
          const myLK = gameState.playerLuck[myIndex] || 0;
          const opponentLK = gameState.playerLuck[opponentIndex] || 0;
          const lkDiff = Math.abs(myLK - opponentLK);

          if (
            winnerIndex === myIndex ||
            (gameState.mode !== "online" && winnerIndex === 0)
          ) {
            SoundManager.play("win");
            // Award money for winning - ONLY in online mode
            if (gameState.mode === "online") {
              // Win = get the LK difference
              const earnings = Math.max(1, lkDiff);
              PlayerAccount.addMoney(earnings);
              updateAccountDisplay();
            }
          } else {
            SoundManager.play("lose");
            // Deduct money for losing - ONLY in online mode
            if (gameState.mode === "online") {
              // Lose = lose 20% of LK difference (minimum 0)
              const loss = Math.floor(lkDiff * 0.2);
              if (loss > 0) {
                PlayerAccount.removeMoney(loss);
                updateAccountDisplay();
              }
            }
          }
        } else {
          // Tie - tiebreaker
          SoundManager.play("tie");
          resultTitle = t("tiebreaker");
          const winnerNames = winners
            .map((i) => gameState.playerNames[i])
            .join(currentLang === "pl" ? " i " : " and ");
          winner = `${winnerNames} - ${
            currentLang === "pl" ? "dogrywka" : "tiebreaker"
          }!`;
          gameState.tiebreakerPot = allCardsToWin;
          startTiebreaker();
        }

        document.getElementById("resultTitle").textContent = resultTitle;
        document.getElementById("resultWinner").textContent = winner;
        document.getElementById("resultPenalty").textContent = penalty;
        document.getElementById("roundResult").classList.add("active");

        updateDisplay();
      }

      function continueGame() {
        document.getElementById("roundResult").classList.remove("active");

        // In online mode, send continue signal
        if (gameState.mode === "online") {
          const message = { type: "continue" };
          if (onlineState.isHost) {
            broadcastToAll(message);
          } else if (onlineState.connections.length > 0) {
            onlineState.connections[0].send(message);
          }
        }

        // Check for game over
        if (
          gameState.scores[0] >= gameState.targetScore ||
          gameState.scores[1] >= gameState.targetScore
        ) {
          endGame();
        } else if (!gameState.inTiebreaker) {
          prepareNextRound();
        } else {
          // Continue tiebreaker
          prepareTiebreakerRound();
        }
      }

      function startTiebreaker() {
        gameState.inTiebreaker = true;
        gameState.tiebreakerLevel++;
        document.getElementById("tiebreakerIndicator").classList.add("active");
      }

      function resetTiebreaker() {
        gameState.inTiebreaker = false;
        gameState.tiebreakerLevel = 0;
        gameState.tiebreakerPot = [];
        gameState.cardsToPlay = 4;
        document
          .getElementById("tiebreakerIndicator")
          .classList.remove("active");
      }

      function prepareTiebreakerRound() {
        // Clear played cards
        document.getElementById("playedCards1").innerHTML = "";
        document.getElementById("playedCards2").innerHTML = "";

        gameState.playedCards = [[], []];
        gameState.playersReady = [false, false];
        gameState.waitingForSecondPlayer = false;

        // Set cards to play based on tiebreaker level
        if (gameState.tiebreakerLevel === 1) {
          gameState.cardsToPlay = 2;
        } else {
          gameState.cardsToPlay = 1;
        }

        // Check if players need cards for tiebreaker
        for (let i = 0; i < 2; i++) {
          if (gameState.decks[i].length < gameState.cardsToPlay) {
            // Each opponent gives 2 cards
            const opponentIndex = 1 - i;
            if (gameState.decks[opponentIndex].length >= 2) {
              const transferCards = gameState.decks[opponentIndex].splice(0, 2);
              gameState.decks[i].push(...transferCards);
            }
          }
        }

        // Enable buttons based on mode
        document.getElementById("playBtn1").disabled = false;
        if (gameState.mode === "local") {
          document.getElementById("playBtn2").disabled = true;
          updateTurnIndicator();
        } else if (gameState.mode === "online") {
          document.getElementById("playBtn1").disabled = false;
        }

        updateDisplay();
      }

      function prepareNextRound() {
        // Clear played cards
        document.getElementById("playedCards1").innerHTML = "";
        document.getElementById("playedCards2").innerHTML = "";

        gameState.playedCards = [[], []];
        gameState.playersReady = [false, false];
        gameState.cardsToPlay = 4;
        gameState.waitingForSecondPlayer = false;

        // Check if players have cards (transfer if needed)
        for (let i = 0; i < (gameState.maxPlayers || 2); i++) {
          checkAndTransferCards(i);
        }

        // Check if game should end (no more cards anywhere)
        const totalCards = gameState.decks.reduce(
          (sum, deck) => sum + deck.length,
          0
        );
        if (totalCards < gameState.cardsToPlay * 2) {
          // Not enough cards to play - end game, highest score wins
          endGame();
          return;
        }

        // Enable buttons based on mode
        document.getElementById("playBtn1").disabled = false;
        if (gameState.mode === "local") {
          document.getElementById("playBtn2").disabled = true;
          updateTurnIndicator();
        } else if (gameState.mode === "online") {
          // In online mode, button is always playBtn1
          document.getElementById("playBtn1").disabled = false;
        }

        updateDisplay();
      }

      // ==================== SURRENDER SYSTEM ====================

      function confirmSurrender() {
        // Show info about online mode
        if (gameState.mode === "online") {
          document.getElementById("surrenderOnlineInfo").style.display =
            "block";
        } else {
          document.getElementById("surrenderOnlineInfo").style.display = "none";
        }
        document.getElementById("surrenderModal").classList.add("active");
      }

      function closeSurrenderModal() {
        document.getElementById("surrenderModal").classList.remove("active");
      }

      function surrender() {
        closeSurrenderModal();

        if (gameState.mode === "online") {
          // Online: notify opponent and go to game over with rematch option
          const myIndex = onlineState.myPlayerIndex;
          const opponentIndex = myIndex === 0 ? 1 : 0;

          // Opponent wins
          gameState.scores[opponentIndex] = gameState.targetScore;

          // Send surrender message
          const message = {
            type: "surrender",
            playerIndex: myIndex,
            playerName: gameState.playerNames[myIndex],
          };

          if (onlineState.isHost) {
            broadcastToAll(message);
          } else if (
            onlineState.connections &&
            onlineState.connections.length > 0
          ) {
            onlineState.connections[0].send(message);
          }

          // Show game over with rematch
          endGameWithSurrender(gameState.playerNames[myIndex]);
        } else {
          // Offline: just go back to menu
          document.getElementById("gameScreen").classList.remove("active");
          document.getElementById("liveScores").style.display = "none";
          document.getElementById("menuScreen").style.display = "flex";
          document.getElementById("helpBtn").classList.remove("hidden");
        }
      }

      function receiveSurrender(data) {
        // Opponent surrendered - we win!
        const surrendererName = data.playerName;
        endGameWithSurrender(surrendererName);
      }

      function endGameWithSurrender(surrendererName) {
        gameState.gameOver = true;

        document.getElementById(
          "gameWinner"
        ).textContent = `${surrendererName} ${t("surrendered")}`;
        document.getElementById("finalScore1").textContent =
          gameState.scores[0];
        document.getElementById("finalScore2").textContent =
          gameState.scores[1];

        // Hide turn indicators
        const playerArea1 = document.querySelector(".player-area:not(.top)");
        const playerArea2 = document.querySelector(".player-area.top");
        if (playerArea1) playerArea1.classList.remove("active-turn");
        if (playerArea2) playerArea2.classList.remove("active-turn");

        // Show rematch section for online mode
        document.getElementById("rematchSection").style.display = "block";
        document.getElementById("backToMenuBtn").style.display = "none";
        resetRematchVotes();

        document.getElementById("gameOverScreen").classList.add("active");
      }

      function endGame() {
        gameState.gameOver = true;

        const winnerIndex = gameState.scores[0] > gameState.scores[1] ? 0 : 1;
        const winner = gameState.playerNames[winnerIndex];

        // Play sound based on who won
        const myIndex =
          gameState.mode === "online" ? onlineState.myPlayerIndex : 0;
        if (winnerIndex === myIndex || gameState.mode === "bot") {
          SoundManager.play("gameWin");
        } else {
          SoundManager.play("gameLose");
        }

        document.getElementById("gameWinner").textContent = `${winner} ${t(
          "winsGame"
        )}`;
        document.getElementById("finalScore1").textContent =
          gameState.scores[0];
        document.getElementById("finalScore2").textContent =
          gameState.scores[1];

        // Hide turn indicators
        const playerArea1 = document.querySelector(".player-area:not(.top)");
        const playerArea2 = document.querySelector(".player-area.top");
        if (playerArea1) playerArea1.classList.remove("active-turn");
        if (playerArea2) playerArea2.classList.remove("active-turn");

        // Show rematch section for online and local 2-player modes
        if (gameState.mode === "online") {
          document.getElementById("rematchSection").style.display = "block";
          document.getElementById("backToMenuBtn").style.display = "none";
          document.getElementById("rematchVotes").style.display = "block";
          resetRematchVotes();
        } else if (gameState.mode === "local") {
          // Local 2-player mode - simple rematch (one click decides)
          document.getElementById("rematchSection").style.display = "block";
          document.getElementById("backToMenuBtn").style.display = "none";
          document.getElementById("rematchVotes").style.display = "none"; // No voting display needed
          document.getElementById("rematchResult").textContent = "";
          document.getElementById("rematchYesBtn").disabled = false;
          document.getElementById("rematchNoBtn").disabled = false;
          document.getElementById("rematchYesBtn").classList.remove("selected");
          document.getElementById("rematchNoBtn").classList.remove("selected");
        } else {
          // Bot mode - no rematch, just back to menu
          document.getElementById("rematchSection").style.display = "none";
          document.getElementById("backToMenuBtn").style.display = "block";
        }

        document.getElementById("gameOverScreen").classList.add("active");
      }

      // Rematch voting system
      const rematchState = {
        votes: {}, // {playerIndex: true/false/null}
        myVote: null,
        totalPlayers: 2,
      };

      function resetRematchVotes() {
        rematchState.votes = {};
        rematchState.myVote = null;
        rematchState.totalPlayers = gameState.maxPlayers || 2;

        document.getElementById("rematchYesBtn").disabled = false;
        document.getElementById("rematchNoBtn").disabled = false;
        document.getElementById("rematchYesBtn").classList.remove("selected");
        document.getElementById("rematchNoBtn").classList.remove("selected");
        document.getElementById("rematchResult").textContent = "";
        document.getElementById("rematchResult").className = "rematch-result";
        document.getElementById("voteStatus").textContent =
          t("waitingForVotes");

        updateVoteDisplay();
      }

      function voteRematch(wantRematch) {
        // Local mode - instant decision
        if (gameState.mode === "local") {
          document.getElementById("rematchYesBtn").disabled = true;
          document.getElementById("rematchNoBtn").disabled = true;

          if (wantRematch) {
            document.getElementById("rematchYesBtn").classList.add("selected");
            document.getElementById("rematchResult").textContent =
              t("rematchAccepted");
            document.getElementById("rematchResult").className =
              "rematch-result success";
            setTimeout(function () {
              startLocalRematch();
            }, 1500);
          } else {
            document.getElementById("rematchNoBtn").classList.add("selected");
            backToMenu();
          }
          return;
        }

        // Online mode - voting system
        rematchState.myVote = wantRematch;
        rematchState.votes[onlineState.myPlayerIndex] = wantRematch;

        // Update buttons
        document.getElementById("rematchYesBtn").disabled = true;
        document.getElementById("rematchNoBtn").disabled = true;

        if (wantRematch) {
          document.getElementById("rematchYesBtn").classList.add("selected");
        } else {
          document.getElementById("rematchNoBtn").classList.add("selected");
        }

        // Send vote to other players
        const message = {
          type: "rematchVote",
          playerIndex: onlineState.myPlayerIndex,
          vote: wantRematch,
        };

        if (onlineState.isHost) {
          broadcastToAll(message);
        } else if (
          onlineState.connections &&
          onlineState.connections.length > 0
        ) {
          onlineState.connections[0].send(message);
        }

        updateVoteDisplay();
        checkRematchResult();
      }

      function startLocalRematch() {
        // Hide game over screen
        document.getElementById("gameOverScreen").classList.remove("active");

        // Reset game state
        gameState.scores = [0, 0];
        gameState.playedCards = [[], []];
        gameState.playersReady = [false, false];
        gameState.roundPoints = [0, 0];
        gameState.cardsToPlay = 4;
        gameState.inTiebreaker = false;
        gameState.tiebreakerLevel = 0;
        gameState.tiebreakerPot = [];
        gameState.wonCardsPile = [];
        gameState.gameOver = false;
        gameState.waitingForSecondPlayer = false;

        // Deal new cards
        dealCards();

        // Clear played cards display
        document.getElementById("playedCards1").innerHTML = "";
        document.getElementById("playedCards2").innerHTML = "";

        // Re-enable play button
        document.getElementById("playBtn1").disabled = false;
        if (gameState.mode === "local") {
          document.getElementById("playBtn2").disabled = true;
          updateTurnIndicator();
        }

        updateDisplay();
      }

      function receiveRematchVote(playerIndex, vote) {
        rematchState.votes[playerIndex] = vote;
        updateVoteDisplay();
        checkRematchResult();
      }

      function updateVoteDisplay() {
        let statusHtml = "";

        for (let i = 0; i < rematchState.totalPlayers; i++) {
          const playerName =
            gameState.playerNames[i] || t("player1").replace("1", i + 1);
          const vote = rematchState.votes[i];

          let voteClass = "waiting";
          let voteText = "?";

          if (vote === true) {
            voteClass = "yes";
            voteText = "âœ“";
          } else if (vote === false) {
            voteClass = "no";
            voteText = "âœ—";
          }

          statusHtml += `<span class="player-vote ${voteClass}">${playerName}: ${voteText}</span> `;
        }

        document.getElementById("voteStatus").innerHTML = statusHtml;
      }

      function checkRematchResult() {
        const votes = Object.values(rematchState.votes);

        // Check if all players voted
        if (votes.length < rematchState.totalPlayers) {
          return; // Still waiting for votes
        }

        // Check if anyone voted NO
        const anyNo = votes.some((v) => v === false);
        const allYes = votes.every((v) => v === true);

        if (anyNo) {
          // Someone declined - no rematch
          document.getElementById("rematchResult").textContent =
            t("rematchRejected");
          document.getElementById("rematchResult").className =
            "rematch-result failed";
          document.getElementById("backToMenuBtn").style.display = "block";
        } else if (allYes) {
          // Everyone agreed - start new game!
          document.getElementById("rematchResult").textContent =
            t("rematchAccepted");
          document.getElementById("rematchResult").className =
            "rematch-result success";

          setTimeout(function () {
            startRematch();
          }, 2000);
        }
      }

      function startRematch() {
        // Hide game over screen
        document.getElementById("gameOverScreen").classList.remove("active");

        // Reset game state but keep players
        gameState.scores = new Array(gameState.maxPlayers || 2).fill(0);
        gameState.playedCards = new Array(gameState.maxPlayers || 2)
          .fill(null)
          .map(() => []);
        gameState.playersReady = new Array(gameState.maxPlayers || 2).fill(
          false
        );
        gameState.roundPoints = new Array(gameState.maxPlayers || 2).fill(0);
        gameState.cardsToPlay = 4;
        gameState.inTiebreaker = false;
        gameState.tiebreakerLevel = 0;
        gameState.tiebreakerPot = [];
        gameState.wonCardsPile = [];
        gameState.gameOver = false;

        // If host, create new deck and send to all
        if (onlineState.isHost) {
          dealCards();

          // Send new game state to all players
          broadcastToAll({
            type: "rematchStart",
            decks: gameState.decks,
            playerNames: gameState.playerNames,
          });
        }

        // Clear played cards display
        document.getElementById("playedCards1").innerHTML = "";
        document.getElementById("playedCards2").innerHTML = "";

        // Re-enable play button
        document.getElementById("playBtn1").disabled = false;

        updateDisplay();
      }

      function receiveRematchStart(data) {
        // Hide game over screen
        document.getElementById("gameOverScreen").classList.remove("active");

        // Reset game state
        gameState.decks = data.decks;
        gameState.playerNames = data.playerNames;
        gameState.scores = new Array(gameState.maxPlayers || 2).fill(0);
        gameState.playedCards = new Array(gameState.maxPlayers || 2)
          .fill(null)
          .map(() => []);
        gameState.playersReady = new Array(gameState.maxPlayers || 2).fill(
          false
        );
        gameState.roundPoints = new Array(gameState.maxPlayers || 2).fill(0);
        gameState.cardsToPlay = 4;
        gameState.inTiebreaker = false;
        gameState.tiebreakerLevel = 0;
        gameState.tiebreakerPot = [];
        gameState.wonCardsPile = [];
        gameState.gameOver = false;

        // Clear played cards display
        document.getElementById("playedCards1").innerHTML = "";
        document.getElementById("playedCards2").innerHTML = "";

        // Re-enable play button
        document.getElementById("playBtn1").disabled = false;

        updateDisplay();
      }

      // Keyboard controls
      document.addEventListener("keydown", function (e) {
        // Ignore if modal is open
        if (
          document.getElementById("surrenderModal").classList.contains("active")
        )
          return;
        if (
          document
            .getElementById("instructionsModal")
            .classList.contains("active")
        )
          return;

        // Handle continue button when result is shown
        if (
          document.getElementById("roundResult").classList.contains("active")
        ) {
          if (e.code === "Space" || e.code === "Enter") {
            e.preventDefault();
            continueGame();
          }
          return;
        }

        // Don't process if game is not active
        if (gameState.gameOver) return;
        if (!document.getElementById("gameScreen").classList.contains("active"))
          return;

        if (e.code === "Space") {
          e.preventDefault();
          if (gameState.mode === "local") {
            if (
              !gameState.waitingForSecondPlayer &&
              !gameState.playersReady[0]
            ) {
              playCards(1);
            }
          } else {
            if (!gameState.playersReady[0]) {
              playCards(1);
            }
          }
        } else if (e.code === "ArrowUp" && gameState.mode === "local") {
          e.preventDefault();
          if (gameState.waitingForSecondPlayer && !gameState.playersReady[1]) {
            playCards(2);
          }
        }
      });

      // Close modal on outside click
      document
        .getElementById("instructionsModal")
        .addEventListener("click", (e) => {
          if (e.target === document.getElementById("instructionsModal")) {
            closeInstructions();
          }
        });

      // ==================== ONLINE MULTIPLAYER ====================

      // Load PeerJS library
      const peerScript = document.createElement("script");
      peerScript.src = "https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js";
      document.head.appendChild(peerScript);

      // Online state
      const onlineState = {
        peer: null,
        connections: [], // Array for multiple connections (4 player mode)
        isHost: false,
        roomId: null,
        myName: "",
        myPlayerIndex: 0,
        players: [], // {id, name, conn}
        maxPlayers: 2,
        ready: false,
      };

      function updatePlayerSlots() {
        const count = parseInt(
          document.querySelector('[data-option="playerCount"].selected')
            ?.dataset.value || "2"
        );
        onlineState.maxPlayers = count;

        document.getElementById("maxPlayersDisplay").textContent = count;

        // Show/hide slots
        document
          .getElementById("playerSlot3")
          .classList.toggle("hidden", count < 4);
        document
          .getElementById("playerSlot4")
          .classList.toggle("hidden", count < 4);

        // Update waiting status
        for (let i = 3; i <= 4; i++) {
          if (count >= i) {
            document.getElementById(`playerSlot${i}`).classList.add("waiting");
            document.getElementById(`lobbyPlayer${i}Name`).textContent =
              t("waiting");
          }
        }

        checkIfCanStart();
      }

      function showSetup(type) {
        document.getElementById("menuScreen").style.display = "none";

        if (type === "online") {
          document.getElementById("onlineLobby").classList.add("active");
          // Show initial choice section
          document.getElementById("onlineChoiceSection").style.display =
            "block";
          document.getElementById("hostLobbySection").style.display = "none";
          document.getElementById("guestLobbySection").style.display = "none";

          // Set player name from account
          const nameInput = document.getElementById("onlinePlayerName");
          if (nameInput && PlayerAccount.name) {
            nameInput.value = PlayerAccount.name;
          }
        } else {
          document.getElementById("setupScreen").classList.add("active");
          initLuckSliders();

          // Set player name from account
          const nameInput = document.getElementById("player1Name");
          if (nameInput && PlayerAccount.name) {
            nameInput.value = PlayerAccount.name;
          }
        }
      }

      function joinRoomFromInput() {
        const codeInput = document.getElementById("joinRoomCode");
        let input = codeInput.value.trim();

        if (!input) {
          alert(
            currentLang === "pl"
              ? "Wpisz kod lub link do pokoju!"
              : "Enter room code or link!"
          );
          return;
        }

        let code = "";

        // Check if it's a full URL with ?room= parameter
        if (input.includes("?room=")) {
          try {
            const url = new URL(input);
            code = url.searchParams.get("room") || "";
          } catch (e) {
            // Try regex as fallback
            const match = input.match(/[?&]room=([^&]+)/);
            if (match) {
              code = match[1];
            }
          }
        } else if (input.includes("room=")) {
          // Handle partial URL like "?room=C4-ABC123"
          const match = input.match(/room=([^&]+)/);
          if (match) {
            code = match[1];
          }
        } else {
          // It's just a code
          code = input.toUpperCase();
        }

        if (!code) {
          alert(
            currentLang === "pl"
              ? "NieprawidÅ‚owy kod lub link!"
              : "Invalid code or link!"
          );
          return;
        }

        // Add prefix if missing
        code = code.toUpperCase();
        if (!code.startsWith("C4-")) {
          code = "C4-" + code;
        }

        joinRoom(code);
      }

      function createRoom() {
        onlineState.isHost = true;
        onlineState.players = [];

        // Generate room code
        const roomId =
          "C4-" + Math.random().toString(36).substr(2, 6).toUpperCase();
        onlineState.roomId = roomId;

        // Show host lobby section
        document.getElementById("onlineChoiceSection").style.display = "none";
        document.getElementById("hostLobbySection").style.display = "block";
        document.getElementById("guestLobbySection").style.display = "none";

        // Generate shareable link
        let currentUrl = "";
        try {
          currentUrl = window.location.origin + window.location.pathname;
        } catch (e) {
          currentUrl = window.location.href.split("?")[0].split("#")[0];
        }
        const shareLink = currentUrl + "?room=" + roomId;

        // Update UI immediately
        document.getElementById("lobbyLinkText").innerText = shareLink;
        document.getElementById("lobbyLinkContainer").style.cssText =
          "display: block !important;";
        document.getElementById("lobbyStatus").innerText = t("roomCreated");
        document.getElementById("lobbyStatus").className =
          "lobby-status connected";
        document.getElementById("playerCountGroup").style.display = "block";

        // Update host slot
        updateMyNameInLobby();
        document.getElementById("playerSlot1").className = "player-slot ready";
        document.getElementById("player1Status").innerText = t("hostYou");

        updatePlayerCount();

        // Initialize PeerJS connection
        initPeerConnection();
      }

      function initPeerConnection() {
        const checkPeer = setInterval(function () {
          if (typeof Peer !== "undefined") {
            clearInterval(checkPeer);
            initializePeer();
          }
        }, 100);

        setTimeout(function () {
          if (!onlineState.peer) {
            document.getElementById("lobbyStatus").innerText =
              "BÅ‚Ä…d poÅ‚Ä…czenia P2P. Upewnij siÄ™ Å¼e masz internet.";
            document.getElementById("lobbyStatus").className =
              "lobby-status error";
          }
        }, 15000);
      }

      function initializePeer() {
        // Use already generated room ID
        const roomId = onlineState.roomId;

        // Now initialize peer
        try {
          onlineState.peer = new Peer(roomId.toLowerCase());

          onlineState.peer.on("open", (id) => {
            console.log("Peer opened with ID:", id);
            document.getElementById("lobbyStatus").textContent = t("roomReady");
            document.getElementById("lobbyStatus").classList.add("connected");
            document.getElementById("lobbyStatus").classList.remove("error");
          });

          onlineState.peer.on("connection", (conn) => {
            console.log("Incoming connection from:", conn.peer);
            handleNewConnection(conn);
          });

          onlineState.peer.on("error", (err) => {
            console.error("Peer error:", err);
            document.getElementById("lobbyStatus").textContent =
              "BÅ‚Ä…d poÅ‚Ä…czenia: " + err.type;
            document.getElementById("lobbyStatus").classList.add("error");
            document
              .getElementById("lobbyStatus")
              .classList.remove("connected");
          });
        } catch (e) {
          console.error("Failed to create peer:", e);
          document.getElementById("lobbyStatus").textContent =
            "BÅ‚Ä…d: Nie moÅ¼na utworzyÄ‡ poÅ‚Ä…czenia";
          document.getElementById("lobbyStatus").classList.add("error");
        }
      }

      function handleNewConnection(conn) {
        if (onlineState.players.length >= onlineState.maxPlayers - 1) {
          // Room full
          conn.on("open", () => {
            conn.send({ type: "roomFull" });
            setTimeout(() => conn.close(), 100);
          });
          return;
        }

        conn.on("open", () => {
          SoundManager.play("join");
          const playerIndex = onlineState.players.length + 1; // 1, 2, 3 (host is 0)
          onlineState.players.push({
            id: conn.peer,
            name: t("player1").replace("1", String(playerIndex + 1)),
            conn: conn,
          });

          // Send current lobby state
          conn.send({
            type: "lobbyState",
            playerIndex: playerIndex,
            maxPlayers: onlineState.maxPlayers,
            targetScore: parseInt(
              document.querySelector('[data-option="onlineTarget"].selected')
                ?.dataset.value || "2660"
            ),
            players: [
              { name: onlineState.myName || t("host"), index: 0 },
              ...onlineState.players.map((p, i) => ({
                name: p.name,
                index: i + 1,
              })),
            ],
          });

          // Broadcast to other players
          broadcastToOthers(conn.peer, {
            type: "playerJoined",
            playerIndex: playerIndex,
            name: "Gracz " + (playerIndex + 1),
          });

          updateLobbyUI();
        });

        conn.on("data", (data) => handleOnlineMessage(data, conn));

        conn.on("close", () => {
          const idx = onlineState.players.findIndex((p) => p.id === conn.peer);
          if (idx !== -1) {
            onlineState.players.splice(idx, 1);
            updateLobbyUI();
            broadcastToAll({ type: "playerLeft", playerIndex: idx + 1 });
          }
        });
      }

      function joinRoom(roomId) {
        onlineState.isHost = false;
        onlineState.roomId = roomId;

        // Show guest lobby section
        document.getElementById("onlineChoiceSection").style.display = "none";
        document.getElementById("hostLobbySection").style.display = "none";
        document.getElementById("guestLobbySection").style.display = "block";

        document.getElementById("guestLobbyStatus").textContent =
          t("connectingToRoom") + " " + roomId + "...";

        // Set guest name
        const myName =
          document.getElementById("onlinePlayerName").value.trim() ||
          t("player2");
        onlineState.myName = myName;
        document.getElementById("guestPlayer2Name").textContent = myName;

        // Wait for PeerJS to load
        const checkPeer = setInterval(() => {
          if (typeof Peer !== "undefined") {
            clearInterval(checkPeer);
            connectToRoom(roomId);
          }
        }, 100);
      }

      function connectToRoom(roomId, retryCount = 0) {
        const maxRetries = 3;
        const peerId = roomId.toLowerCase(); // Host uÅ¼ywa lowercase

        try {
          onlineState.peer = new Peer();

          onlineState.peer.on("open", () => {
            console.log("Connecting to room:", peerId);
            const conn = onlineState.peer.connect(peerId, { reliable: true });

            // Timeout for connection
            const connectionTimeout = setTimeout(() => {
              if (!conn.open) {
                conn.close();
                if (retryCount < maxRetries) {
                  document.getElementById("guestLobbyStatus").textContent =
                    currentLang === "pl"
                      ? `Ponawiam prÃ³bÄ™ (${retryCount + 1}/${maxRetries})...`
                      : `Retrying (${retryCount + 1}/${maxRetries})...`;
                  onlineState.peer.destroy();
                  setTimeout(() => connectToRoom(roomId, retryCount + 1), 1000);
                } else {
                  document.getElementById("guestLobbyStatus").textContent =
                    currentLang === "pl"
                      ? "Nie moÅ¼na poÅ‚Ä…czyÄ‡ - pokÃ³j nie istnieje lub host siÄ™ rozÅ‚Ä…czyÅ‚"
                      : "Cannot connect - room does not exist or host disconnected";
                  document
                    .getElementById("guestLobbyStatus")
                    .classList.add("error");
                }
              }
            }, 5000);

            onlineState.connections.push(conn);

            conn.on("open", () => {
              clearTimeout(connectionTimeout);
              document.getElementById("guestLobbyStatus").textContent = t(
                "connectedWaitingHost"
              );
              document
                .getElementById("guestLobbyStatus")
                .classList.add("connected");

              // Send my name
              conn.send({ type: "name", name: onlineState.myName });
            });

            conn.on("data", (data) => handleOnlineMessage(data, conn));

            conn.on("close", () => {
              clearTimeout(connectionTimeout);
              document.getElementById("guestLobbyStatus").textContent =
                t("hostDisconnected");
              document
                .getElementById("guestLobbyStatus")
                .classList.remove("connected");
              document
                .getElementById("guestLobbyStatus")
                .classList.add("error");
            });

            conn.on("error", (err) => {
              clearTimeout(connectionTimeout);
              console.error("Connection error:", err);
            });
          });

          onlineState.peer.on("error", (err) => {
            console.error("Peer error:", err);

            let errorMsg = "";
            if (err.type === "peer-unavailable") {
              errorMsg = t("roomNotFound");
            } else if (err.type === "network") {
              errorMsg =
                currentLang === "pl"
                  ? "BÅ‚Ä…d sieci - sprawdÅº poÅ‚Ä…czenie internetowe"
                  : "Network error - check your internet connection";
            } else {
              errorMsg = t("connectionError") + ": " + err.type;
            }

            document.getElementById("guestLobbyStatus").textContent = errorMsg;
            document.getElementById("guestLobbyStatus").classList.add("error");
            document.getElementById("retryConnectBtn").style.display = "block";
          });
        } catch (e) {
          document.getElementById("guestLobbyStatus").textContent =
            (currentLang === "pl" ? "BÅ‚Ä…d: " : "Error: ") + e.message;
          document.getElementById("guestLobbyStatus").classList.add("error");
        }
      }

      function retryConnect() {
        document.getElementById("retryConnectBtn").style.display = "none";
        document.getElementById("guestLobbyStatus").textContent =
          t("connectingToRoom") + "...";
        document.getElementById("guestLobbyStatus").classList.remove("error");

        if (onlineState.peer) {
          onlineState.peer.destroy();
        }
        onlineState.connections = [];

        connectToRoom(onlineState.roomId, 0);
      }

      function broadcastToAll(data) {
        onlineState.players.forEach((p) => {
          if (p.conn && p.conn.open) {
            p.conn.send(data);
          }
        });
      }

      function broadcastToOthers(excludeId, data) {
        onlineState.players.forEach((p) => {
          if (p.id !== excludeId && p.conn && p.conn.open) {
            p.conn.send(data);
          }
        });
      }

      function handleOnlineMessage(data, conn) {
        console.log("Received:", data);

        switch (data.type) {
          case "roomFull":
            document.getElementById("lobbyStatus").textContent = t("roomFull");
            document.getElementById("lobbyStatus").classList.add("error");
            break;

          case "lobbyState":
            onlineState.myPlayerIndex = data.playerIndex;
            onlineState.maxPlayers = data.maxPlayers;
            document.getElementById("maxPlayersDisplay").textContent =
              data.maxPlayers;

            // Update all player slots
            data.players.forEach((p) => {
              document.getElementById(
                `lobbyPlayer${p.index + 1}Name`
              ).textContent = p.name;
              document
                .getElementById(`playerSlot${p.index + 1}`)
                .classList.add("ready");
              document
                .getElementById(`playerSlot${p.index + 1}`)
                .classList.remove("waiting");
            });

            // Mark my slot
            const mySlot = data.playerIndex + 1;
            document.getElementById(`player${mySlot}Status`).textContent =
              "(Ty)";
            document
              .getElementById(`player${mySlot}Status`)
              .classList.add("you");

            updatePlayerSlots();
            updatePlayerCount();
            break;

          case "name":
          case "nameUpdate":
            if (onlineState.isHost) {
              const player = onlineState.players.find((p) => p.conn === conn);
              if (player) {
                player.name = data.name || "Gracz";
                updateLobbyUI();
                // Broadcast name change to others
                broadcastToOthers(conn.peer, {
                  type: "playerNameUpdate",
                  playerIndex: onlineState.players.indexOf(player) + 1,
                  name: player.name,
                });
              }
            }
            break;

          case "playerJoined":
            document.getElementById(
              `lobbyPlayer${data.playerIndex + 1}Name`
            ).textContent = data.name;
            document
              .getElementById(`playerSlot${data.playerIndex + 1}`)
              .classList.add("ready");
            document
              .getElementById(`playerSlot${data.playerIndex + 1}`)
              .classList.remove("waiting");
            updatePlayerCount();
            break;

          case "playerNameUpdate":
            document.getElementById(
              `lobbyPlayer${data.playerIndex + 1}Name`
            ).textContent = data.name;
            break;

          case "playerLeft":
            document.getElementById(
              `lobbyPlayer${data.playerIndex + 1}Name`
            ).textContent = t("waiting");
            document
              .getElementById(`playerSlot${data.playerIndex + 1}`)
              .classList.remove("ready");
            document
              .getElementById(`playerSlot${data.playerIndex + 1}`)
              .classList.add("waiting");
            updatePlayerCount();
            break;

          case "startGame":
            receiveGameStart(data);
            break;

          case "playCards":
            receivePlayedCards(data);
            break;

          case "continue":
            if (
              !document
                .getElementById("roundResult")
                .classList.contains("active")
            )
              return;
            continueGame();
            break;

          case "rematchVote":
            receiveRematchVote(data.playerIndex, data.vote);
            // If host, broadcast to other players
            if (onlineState.isHost) {
              broadcastToOthers(conn ? conn.peer : null, data);
            }
            break;

          case "rematchStart":
            receiveRematchStart(data);
            break;

          case "surrender":
            receiveSurrender(data);
            // If host, broadcast to others
            if (onlineState.isHost) {
              broadcastToOthers(conn ? conn.peer : null, data);
            }
            break;
        }
      }

      function updateLobbyUI() {
        // Update host name
        document.getElementById("lobbyPlayer1Name").textContent =
          onlineState.myName || t("host");

        // Update other players
        for (let i = 0; i < onlineState.maxPlayers - 1; i++) {
          const slot = document.getElementById(`playerSlot${i + 2}`);
          const nameEl = document.getElementById(`lobbyPlayer${i + 2}Name`);

          if (i < onlineState.players.length) {
            nameEl.textContent = onlineState.players[i].name;
            slot.classList.add("ready");
            slot.classList.remove("waiting");
          } else {
            nameEl.textContent = t("waiting");
            slot.classList.remove("ready");
            slot.classList.add("waiting");
          }
        }

        updatePlayerCount();
        checkIfCanStart();
      }

      function updatePlayerCount() {
        const count = onlineState.isHost
          ? onlineState.players.length + 1
          : document.querySelectorAll(".player-slot.ready:not(.hidden)").length;
        document.getElementById("playerCountDisplay").textContent = count;
      }

      function checkIfCanStart() {
        if (!onlineState.isHost) return;

        const currentPlayers = onlineState.players.length + 1; // +1 for host
        const canStart = currentPlayers === onlineState.maxPlayers;

        const btn = document.getElementById("startOnlineBtn");
        btn.disabled = !canStart;
        btn.textContent = canStart
          ? t("startGame")
          : `${t("waitingForPlayers").replace("...", "")} (${currentPlayers}/${
              onlineState.maxPlayers
            })...`;
      }

      function updateMyNameInLobby() {
        const nameInput = document.getElementById("onlinePlayerName");
        onlineState.myName = nameInput.value.trim() || t("player1");

        if (onlineState.isHost) {
          document.getElementById("lobbyPlayer1Name").textContent =
            onlineState.myName;
        } else {
          const mySlot = onlineState.myPlayerIndex + 1;
          document.getElementById(`lobbyPlayer${mySlot}Name`).textContent =
            onlineState.myName;
        }
      }

      // Update name when typing
      document
        .getElementById("onlinePlayerName")
        ?.addEventListener("input", () => {
          updateMyNameInLobby();
          if (onlineState.isHost) {
            broadcastToAll({
              type: "playerNameUpdate",
              playerIndex: 0,
              name: onlineState.myName,
            });
          } else if (onlineState.connections.length > 0) {
            onlineState.connections[0].send({
              type: "nameUpdate",
              name: onlineState.myName,
            });
          }
        });

      function copyLink() {
        const linkText = document.getElementById("lobbyLinkText").textContent;

        // Try modern clipboard API first
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard
            .writeText(linkText)
            .then(() => {
              showCopyFeedback();
            })
            .catch(() => {
              fallbackCopy(linkText);
            });
        } else {
          fallbackCopy(linkText);
        }
      }

      function fallbackCopy(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-9999px";
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand("copy");
          showCopyFeedback();
        } catch (e) {
          prompt("Skopiuj ten link:", text);
        }
        document.body.removeChild(textArea);
      }

      function showCopyFeedback() {
        const feedback = document.getElementById("copyFeedback");
        feedback.classList.add("show");
        setTimeout(() => feedback.classList.remove("show"), 2000);
      }

      function startOnlineGame() {
        if (!onlineState.isHost) return;

        // Get target score
        const targetScore = parseInt(
          document.querySelector('[data-option="onlineTarget"].selected')
            ?.dataset.value || "2660"
        );

        // Create deck and deal
        const fullDeck = createDeck();
        const cardsPerPlayer = Math.floor(TOTAL_CARDS / onlineState.maxPlayers);

        // Prepare player names and decks
        const playerNames = [onlineState.myName];
        const decks = [fullDeck.slice(0, cardsPerPlayer)];

        onlineState.players.forEach((p, i) => {
          playerNames.push(p.name);
          decks.push(
            fullDeck.slice((i + 1) * cardsPerPlayer, (i + 2) * cardsPerPlayer)
          );
        });

        // Send game start to all players
        broadcastToAll({
          type: "startGame",
          targetScore: targetScore,
          playerNames: playerNames,
          decks: decks,
          maxPlayers: onlineState.maxPlayers,
        });

        // Setup local game state
        gameState.targetScore = targetScore;
        gameState.playerNames = playerNames;
        gameState.decks = decks;
        gameState.mode = "online";
        gameState.maxPlayers = onlineState.maxPlayers;
        onlineState.myPlayerIndex = 0;

        startOnlineGameplay();
      }

      function receiveGameStart(data) {
        gameState.targetScore = data.targetScore;
        gameState.playerNames = data.playerNames;
        gameState.decks = data.decks;
        gameState.mode = "online";
        gameState.maxPlayers = data.maxPlayers;

        startOnlineGameplay();
      }

      function startOnlineGameplay() {
        // Hide lobby, show game
        document.getElementById("onlineLobby").classList.remove("active");
        document.getElementById("gameScreen").classList.add("active");
        document.getElementById("liveScores").style.display = "block";

        // Reset game state
        gameState.scores = new Array(gameState.maxPlayers).fill(0);
        gameState.playedCards = new Array(gameState.maxPlayers)
          .fill(null)
          .map(() => []);
        gameState.playersReady = new Array(gameState.maxPlayers).fill(false);
        gameState.roundPoints = new Array(gameState.maxPlayers).fill(0);
        gameState.cardsToPlay = 4;
        gameState.inTiebreaker = false;
        gameState.tiebreakerLevel = 0;
        gameState.tiebreakerPot = [];
        gameState.wonCardsPile = []; // For 4 player mode
        gameState.gameOver = false;

        // Update UI for player count
        updateOnlinePlayerNames();

        // Setup controls
        document.getElementById("player2Controls").style.display = "none";
        document.getElementById("player1ControlWrapper").style.display =
          "block";
        document.getElementById("playBtn1").disabled = false;

        document.getElementById("targetDisplay").textContent =
          gameState.targetScore;
        document.getElementById("liveTarget").textContent =
          gameState.targetScore;

        updateDisplay();
      }

      function receivePlayedCards(data) {
        const playerIndex = data.playerIndex;
        gameState.playedCards[playerIndex] = data.cards;
        gameState.playersReady[playerIndex] = true;
        gameState.decks[playerIndex] = data.remainingDeck;

        displayPlayedCards(playerIndex, data.cards);
        updateDisplay();
        checkRoundEnd();
      }

      function updateOnlinePlayerNames() {
        const name1 = gameState.playerNames[0];
        const name2 = gameState.playerNames[1];

        document.getElementById("player1NameDisplay").textContent = name1;
        document.getElementById("player2Name").textContent = name2;
        document.getElementById("resultPlayer1Name").textContent = name1;
        document.getElementById("resultPlayer2Name").textContent = name2;
        document.getElementById("finalPlayer1Name").textContent = name1;
        document.getElementById("finalPlayer2Name").textContent = name2;
        document.getElementById("livePlayer1Name").textContent = name1;
        document.getElementById("livePlayer2Name").textContent = name2;

        // Update LK displays
        document.getElementById("player1LKDisplay").textContent = `LK: ${
          gameState.playerLuck[0] || 0
        }`;
        document.getElementById("player2LKDisplay").textContent = `LK: ${
          gameState.playerLuck[1] || 0
        }`;
      }

      function leaveLobby() {
        if (onlineState.connections) {
          onlineState.connections.forEach((c) => c.close());
        }
        if (onlineState.players) {
          onlineState.players.forEach((p) => p.conn?.close());
        }
        if (onlineState.peer) {
          onlineState.peer.destroy();
        }

        onlineState.peer = null;
        onlineState.connections = [];
        onlineState.players = [];
        onlineState.isHost = false;
        onlineState.roomId = null;

        document.getElementById("onlineLobby").classList.remove("active");
        document.getElementById("menuScreen").style.display = "flex";

        // Reset lobby UI
        document.getElementById("onlineChoiceSection").style.display = "block";
        document.getElementById("hostLobbySection").style.display = "none";
        document.getElementById("guestLobbySection").style.display = "none";

        document.getElementById("lobbyStatus").textContent =
          "Tworzenie pokoju...";
        document
          .getElementById("lobbyStatus")
          .classList.remove("connected", "error");
        document.getElementById("guestLobbyStatus").textContent = "ÅÄ…czenie...";
        document
          .getElementById("guestLobbyStatus")
          .classList.remove("connected", "error");

        for (let i = 1; i <= 4; i++) {
          const el = document.getElementById(`lobbyPlayer${i}Name`);
          if (el) el.textContent = t("waiting");
          const slot = document.getElementById(`playerSlot${i}`);
          if (slot) {
            slot.classList.remove("ready");
            slot.classList.add("waiting");
          }
          const status = document.getElementById(`player${i}Status`);
          if (status) {
            status.textContent = i === 1 ? "(Host)" : "";
            status.classList.remove("you");
          }
        }
        document.getElementById("startOnlineBtn").disabled = true;
        document.getElementById("startOnlineBtn").textContent =
          "OCZEKIWANIE NA GRACZY...";
        document.getElementById("joinRoomCode").value = "";
      }

      // Check URL for room parameter on page load
      window.addEventListener("DOMContentLoaded", () => {
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const roomId = urlParams.get("room");

          if (roomId) {
            // Auto-join room from link
            document.getElementById("menuScreen").style.display = "none";
            document.getElementById("onlineLobby").classList.add("active");
            document.getElementById("onlineChoiceSection").style.display =
              "block";
            document.getElementById("joinRoomCode").value = roomId;

            // Show message
            setTimeout(() => {
              alert(
                "DoÅ‚Ä…czasz do pokoju: " +
                  roomId +
                  "\n\nWpisz swojÄ… nazwÄ™ i kliknij DOÅÄ„CZ!"
              );
            }, 500);
          }
        } catch (e) {
          console.log("Could not check URL params:", e);
        }
      });
    </script>
  </body>
</html>
